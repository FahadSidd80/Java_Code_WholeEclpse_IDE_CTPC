!SESSION 2023-02-13 10:15:21.155 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

This is a continuation of log file C:\Users\2101917\eclipse-workspace\.metadata\.bak_0.log
Created Time: 2023-02-13 10:37:13.577

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-13 10:37:13.579
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-13 10:37:13.581
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-13 10:37:13.650
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class OperatorsAndAssignment {

	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		//The final local variable x cannot be assigned. It must be blank and not using a compound assignment
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // not clear with concepts.
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for eery primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
//		If we applied any arithemetic operators between two variable a and b the the result type is always
//		max of (int,type of a, type of b)
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
//		
//		byte b = 10;
//		b++;// internal typecasting
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr internal TypeCasting perform automatically
//		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97=0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two contacts.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it access arithmetic addition operators 
//		and sometime it access string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for evry primitive type except boolean.
//		eg
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type inclusding boolean.
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		for any object reference r== null is always false
//		but null == null is always true
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to chek whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is respond to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator the we called CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
		 1+2
	

	}
	public static int m1(int i) {
		System.out.println(i);// 1,2,3,4,5,6
		return i;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-13 10:37:13.654
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-13 10:37:13.656
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-13 10:49:24.260
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class OperatorsAndAssignment {

	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		//The final local variable x cannot be assigned. It must be blank and not using a compound assignment
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // not clear with concepts.
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for eery primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
//		If we applied any arithemetic operators between two variable a and b the the result type is always
//		max of (int,type of a, type of b)
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
//		
//		byte b = 10;
//		b++;// internal typecasting
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr internal TypeCasting perform automatically
//		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97=0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two contacts.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it access arithmetic addition operators 
//		and sometime it access string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for evry primitive type except boolean.
//		eg
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type inclusding boolean.
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		for any object reference r== null is always false
//		but null == null is always true
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to chek whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is respond to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator the we called CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
	    1+1
//		If multiple operator has same precedence then it execute from left to right.

	}
	public static int m1(int i) {
//		System.out.println(i);// 1,2,3,4,5,6
		System.out.println(i);//1,2,3,4,5,6.7,8,9,10
		return i;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-13 10:49:24.265
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-13 10:49:24.267
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-13 10:49:24.297
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class OperatorsAndAssignment {

	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		//The final local variable x cannot be assigned. It must be blank and not using a compound assignment
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // not clear with concepts.
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for eery primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
//		If we applied any arithemetic operators between two variable a and b the the result type is always
//		max of (int,type of a, type of b)
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
//		
//		byte b = 10;
//		b++;// internal typecasting
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr internal TypeCasting perform automatically
//		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97=0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two contacts.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it access arithmetic addition operators 
//		and sometime it access string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for evry primitive type except boolean.
//		eg
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type inclusding boolean.
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		for any object reference r== null is always false
//		but null == null is always true
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to chek whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is respond to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator the we called CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
	    1+1
//		If multiple operator has same precedence then it execute from left to right.

	}
	public static int m1(int i) {
//		System.out.println(i);// 1,2,3,4,5,6
		System.out.println(i);//1,2,3,4,5,6.7,8,9,10
		return i;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-13 10:49:24.301
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-13 10:49:24.303
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:42.918
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1630)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.refreshStatus(LaunchConfigurationsDialog.java:1331)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refreshStatus(LaunchConfigurationTabGroupViewer.java:1117)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.lambda$4(LaunchConfigurationTabGroupViewer.java:738)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.inputChanged(LaunchConfigurationTabGroupViewer.java:742)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput0(LaunchConfigurationTabGroupViewer.java:674)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.setInput(LaunchConfigurationTabGroupViewer.java:654)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:1049)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.lambda$1(LaunchConfigurationsDialog.java:612)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1661)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:1090)
	at org.eclipse.jface.viewers.Viewer.setSelection(Viewer.java:376)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.doInitialTreeSelection(LaunchConfigurationsDialog.java:658)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.initializeContent(LaunchConfigurationsDialog.java:1185)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.createContents(LaunchConfigurationsDialog.java:473)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.create(LaunchConfigurationsDialog.java:378)
	at org.eclipse.jface.window.Window.open(Window.java:788)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:42.920
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:42.931
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTabGroup.performApply(AbstractLaunchConfigurationTabGroup.java:106)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupWrapper.performApply(LaunchConfigurationTabGroupWrapper.java:205)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.handleApplyPressed(LaunchConfigurationTabGroupViewer.java:1503)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:1051)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.lambda$1(LaunchConfigurationsDialog.java:612)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1661)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:1090)
	at org.eclipse.jface.viewers.Viewer.setSelection(Viewer.java:376)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.doInitialTreeSelection(LaunchConfigurationsDialog.java:658)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.initializeContent(LaunchConfigurationsDialog.java:1185)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.createContents(LaunchConfigurationsDialog.java:473)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.create(LaunchConfigurationsDialog.java:378)
	at org.eclipse.jface.window.Window.open(Window.java:788)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:42.931
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:43.007
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.handleLaunchConfigurationSelectionChanged(LaunchConfigurationsDialog.java:1056)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.lambda$1(LaunchConfigurationsDialog.java:612)
	at org.eclipse.jface.viewers.StructuredViewer$3.run(StructuredViewer.java:821)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jface.util.SafeRunnable.run(SafeRunnable.java:174)
	at org.eclipse.jface.viewers.StructuredViewer.firePostSelectionChanged(StructuredViewer.java:818)
	at org.eclipse.jface.viewers.StructuredViewer.setSelection(StructuredViewer.java:1661)
	at org.eclipse.jface.viewers.TreeViewer.setSelection(TreeViewer.java:1090)
	at org.eclipse.jface.viewers.Viewer.setSelection(Viewer.java:376)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.doInitialTreeSelection(LaunchConfigurationsDialog.java:658)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.initializeContent(LaunchConfigurationsDialog.java:1185)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.createContents(LaunchConfigurationsDialog.java:473)
	at org.eclipse.jface.window.Window.create(Window.java:431)
	at org.eclipse.jface.dialogs.Dialog.create(Dialog.java:1094)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.create(LaunchConfigurationsDialog.java:378)
	at org.eclipse.jface.window.Window.open(Window.java:788)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:43.008
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:43.595
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:43.595
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:43.616
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:43.616
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:43.633
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:43.633
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:16:43.650
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab$1.runInUIThread(AbstractLaunchConfigurationTab.java:513)
	at org.eclipse.ui.progress.UIJob.lambda$0(UIJob.java:95)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:16:43.650
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist

!ENTRY org.eclipse.jdt.launching 4 4 2023-02-13 12:17:02.607
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!STACK 1
Java Model Exception: Error in Java Model (code 969): OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
	at org.eclipse.jdt.internal.core.JavaElement.newNotPresentException(JavaElement.java:574)
	at org.eclipse.jdt.internal.core.SourceRefElement.getUnderlyingResource(SourceRefElement.java:241)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.getResource(JavaMigrationDelegate.java:111)
	at org.eclipse.jdt.internal.launching.JavaMigrationDelegate.updateResourceMapping(JavaMigrationDelegate.java:150)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.mapResources(AbstractJavaMainTab.java:213)
	at org.eclipse.jdt.debug.ui.launchConfigurations.JavaMainTab.performApply(JavaMainTab.java:256)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationTabGroupViewer.refresh(LaunchConfigurationTabGroupViewer.java:520)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.updateButtons(LaunchConfigurationsDialog.java:1627)
	at org.eclipse.debug.ui.AbstractLaunchConfigurationTab.updateLaunchConfigurationDialog(AbstractLaunchConfigurationTab.java:155)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab.access$0(AbstractJavaMainTab.java:1)
	at org.eclipse.jdt.internal.debug.ui.launcher.AbstractJavaMainTab$WidgetListener.modifyText(AbstractJavaMainTab.java:64)
	at org.eclipse.swt.widgets.TypedListener.handleEvent(TypedListener.java:183)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1084)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1065)
	at org.eclipse.swt.widgets.Text.wmCommandChild(Text.java:3100)
	at org.eclipse.swt.widgets.Control.WM_COMMAND(Control.java:4904)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4756)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5010)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Text.callWindowProc(Text.java:293)
	at org.eclipse.swt.widgets.Text.windowProc(Text.java:2668)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.CallWindowProc(Native Method)
	at org.eclipse.swt.widgets.Text.callWindowProc(Text.java:293)
	at org.eclipse.swt.widgets.Control.windowProc(Control.java:4854)
	at org.eclipse.swt.widgets.Text.windowProc(Text.java:2681)
	at org.eclipse.swt.widgets.Display.windowProc(Display.java:5002)
	at org.eclipse.swt.internal.win32.OS.DispatchMessage(Native Method)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3630)
	at org.eclipse.jface.window.Window.runEventLoop(Window.java:823)
	at org.eclipse.jface.window.Window.open(Window.java:799)
	at org.eclipse.debug.internal.ui.launchConfigurations.LaunchConfigurationsDialog.open(LaunchConfigurationsDialog.java:1238)
	at org.eclipse.debug.ui.DebugUITools.lambda$1(DebugUITools.java:630)
	at org.eclipse.swt.custom.BusyIndicator.showWhile(BusyIndicator.java:74)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:636)
	at org.eclipse.debug.ui.DebugUITools.openLaunchConfigurationDialogOnGroup(DebugUITools.java:574)
	at org.eclipse.debug.ui.actions.OpenLaunchDialogAction.run(OpenLaunchDialogAction.java:85)
	at org.eclipse.jface.action.Action.runWithEvent(Action.java:474)
	at org.eclipse.jface.action.ActionContributionItem.handleWidgetSelection(ActionContributionItem.java:580)
	at org.eclipse.jface.action.ActionContributionItem.lambda$4(ActionContributionItem.java:414)
	at org.eclipse.swt.widgets.EventTable.sendEvent(EventTable.java:89)
	at org.eclipse.swt.widgets.Display.sendEvent(Display.java:4243)
	at org.eclipse.swt.widgets.Widget.sendEvent(Widget.java:1060)
	at org.eclipse.swt.widgets.Display.runDeferredEvents(Display.java:4060)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3632)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SUBENTRY 1 org.eclipse.jdt.core 4 969 2023-02-13 12:17:02.607
!MESSAGE OperatorsAndAssignment [in [Working copy] OperatorsAndAssignment.java [in <default> [in src [in Java_OperatorsAndAssingment]]]] does not exist
!SESSION 2023-02-14 21:16:44.244 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-14 21:16:54.125
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-14 21:16:54.125
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-14 21:16:54.125
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-14 21:17:04.248
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-15 23:07:31.900 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-15 23:07:47.881
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-15 23:07:47.881
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e8afdad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79b8ecb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-15 23:07:47.881
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3722f39d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec8d9b2,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-15 23:08:00.885
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-16 12:07:26.221 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-16 12:07:34.897
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-16 12:07:34.898
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-16 12:07:34.898
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@173a5fad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce47652,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-16 12:07:43.856
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-19 22:39:20.726 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-19 22:39:32.615
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-19 22:39:32.615
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c0013b8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-19 22:39:32.615
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-19 22:39:45.133
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-20 23:15:46.462 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-20 23:15:56.859
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-20 23:15:56.859
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-20 23:15:56.859
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-20 23:16:07.789
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:55:43.720
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 
						continue l1;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P
		1...0
		2...0
		2...1

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-20 23:55:43.728
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-20 23:55:43.731
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:55:43.796
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 
						continue l1;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P
		1...0
		2...0
		2...1

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:55:43.801
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:55:43.804
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-20 23:55:45.643
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 
						continue l1;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P
		1...0
		2...0
		2...1

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-20 23:55:45.649
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-20 23:55:45.652
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:19:52.405
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						continue;
					System.out.println(i+"..."+j);
					
				}
			}
		
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-21 00:19:52.410
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-21 00:19:52.412
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:19:52.450
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						continue;
					System.out.println(i+"..."+j);
					
				}
			}
		
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-21 00:19:52.454
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-21 00:19:52.457
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:19:52.958
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						continue;
					System.out.println(i+"..."+j);
					
				}
			}
		
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-21 00:19:52.962
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-21 00:19:52.965
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:22:30.963
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						continue;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
		
//		O/P:
//		0...1
//		0...2
//		1...0
//		1...2
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						break;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-21 00:22:30.964
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-21 00:22:30.966
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:22:30.983
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						continue;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
		
//		O/P:
//		0...1
//		0...2
//		1...0
//		1...2
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						break;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-21 00:22:30.985
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-21 00:22:30.987
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:187)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:22:31.492
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						continue;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
		
//		O/P:
//		0...1
//		0...2
//		1...0
//		1...2
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						break;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-21 00:22:31.494
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-21 00:22:31.495
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:23:00.647
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						continue;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
		
//		O/P:
//		0...1
//		0...2
//		1...0
//		1...2
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						break;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P:
//		1...0
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						break l1;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2023-02-21 00:23:00.648
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2023-02-21 00:23:00.649
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2023-02-21 00:23:00.665
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------

public class Flow_Control {

	public static void main(String[] args) {
		// curly braces is optional everywhere except switch-Case
		// Flow Control
		
//		1. Selection Statement
//		2. Iterative statement
//		3. Transfer Statement
		
//		1.  Selection Statement
//			a. if-else
//		    b. Switch-Case
		
//		2.  Iterative statement
//			a. while()
//			b. do-while()
//			c. for()
//			d. for-each loop
		
//		3.  Transfer Statement
//			a. break
//			b. continue
//			c. return
//			d. try-catch-finally
//			e. assert(1.4v)
		
//		1. a if-else
//		int x = 20;
//		if(x) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x= 10;
//		if(x=20) {// Type mismatch: cannot convert from int to boolean
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");
//		}
//		int x = 10;
//		if(x == 20) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii!!
//		}
//		boolean b = true;
//		if(b=false) {
//			System.out.println("Hello!!");
//		}else {
//			System.out.println("Hii!!");// Hii !!
//		}
//		boolean b= false;
//		if(b=false) {
//			System.out.println("Hello!!");// Hello!!
//		}else {
//			System.out.println("Hii!!");
//		}
//		if(true)
//			System.out.println("Hello");// Hello
//		if(true);
//			
//		if(true)
//			int x=10;//
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		if(true) {
//			int x= 10;
//		}
		
//		if(true)
//			if(true)
//				System.out.println("Hello!!");// Hello!!
//			else
//				System.out.println("Hii!!");
//		int x=10;
//		if(x==90) {
//			System.out.println("Hello 10");
//		}else if(x==20) {
//			System.out.println("Hello 20");
//		}else if(x==30) {
//			System.out.println("Hello 30");
//		}else if(x==10) {
//			System.out.println("Hello 10");// Hello 10
//		}else if(x==10) {
//			System.out.println("Hello 120");
//		}else {
//			System.out.println("Hello 80");
//		}
//		
		
//		b. Switch-Case
//		int x=10;
//		switch(x) {
//			case 1:
//					Action-1;
//					break;
//			case 2:
//				Action 2:
//					break;
//			.
//			.
//			.
//			case n:
//				action n;
//				break;
//				
//			default:
//				default action;
//			
//		}
		
//		byte  b = 120;
//		switch(b) {
//		case 1:
//			System.out.println("case 1");
//		case 2:
//			System.out.println("Case 2");
//		case 120:
//			System.out.println("Case 120");
//		}
//		int x =10;
//		switch(x){
//			// Empty switch Statement is also valid
//		}
//		int x=10;
//		switch(x) {
//			System.out.println("Void switch CTE");// Syntax error on token "{", SwitchLabelDefaultExpr expected after this token
//		}
		
//		int x= 20;
//		int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		case y;
//			System.out.println(20);// Syntax error, insert ":: IdentifierOrNew" to complete ReferenceExpression, Syntax error, insert ":" to complete SwitchLabel
//			break;
//		}
		
//		int x= 20;
//		final int y=30;
//		switch(x) {
//		case 10:
//			System.out.println(10);
//			break;
//		 case y;
//			System.out.println(20);
//			break;
//		}
		
		
//		int x = 20;
//		switch(x+1) {
//		case 20:
//			System.out.println("case 10 switch label expression");
//			break;
//		case 1+20:
//			System.out.println("constant expression");
//		}
		
//		byte b = 10;
//		switch(b) {
//			case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");// Type mismatch: cannot convert from int to byte
//		}
		
//		byte b = 10;
//		switch(b+1) {// b+1 -- int dega
//		case 10:
//			System.out.println("Case 10 in range");
//			case 100:
//				System.out.println("Case 100 in range");
//			case 11:
//				System.out.println("Case 11 in range");
//			case 10000:
//				System.out.println("Case 1000 out of  range");
//		}
		
//		int x = 10;
//		switch(x) {
//		case 97:
//			System.out.println("case 97");// Duplicate case
//			break;
//		case 98:
//			System.out.println(98);
//			break;
//		case 99:
//			System.out.println(99);
//			break;
//		case 100:
//			System.out.println(100);
//			break;
//		case 'a':
//			System.out.println("case a");// Duplicate case
//			break;
//		}
		
		
//		Fall through inside switch:
//		int x =0; // 0,1
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1; 
//		switch(x) {// 1
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);// 1
//			break;
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =2; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);// // 2, deff
//		default:
//			System.out.println("deff");// 2, deff
//		}
//		
//		int x =3; 
//		switch(x) {
//		case 0:
//			System.out.println(0);
//		case 1:
//			System.out.println(1);
//			break;
//		case 2:
//			System.out.println(2);
//		default:
//		System.out.println("deff");//  deff
//		}
		
//		int x =0;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);// 0
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
//		int x =1;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);// 1, 2
//		case 2:
//			System.out.println(2);
//		}
		
		
//		int x =2;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'");
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);// 2
//		}
		
//		int x =3;
//		switch(x) {
//		default: /// not recommended
//			System.out.println("deff case'"); // deff case' , 0
//		case 0:
//			System.out.println(0);
//			break;
//		case 1:
//			System.out.println(1);
//		case 2:
//			System.out.println(2);
//		}
		
		
//		Lecture 27: 
		
//		2.  Iterative statement
//		a. while()
//		b. do-while()
//		c. for()
//		d. for-each loop
		
//		a. while()// when don't know no of iteration in  advance 
		
//		while(1) {
//			System.out.println("Integr type");// Type mismatch: cannot convert from int to boolean
//
//		}
		
//		while (true) {// infinit while loop
//			System.out.println("hello");
//		}
		
//		while(true);
//		while(true)
//			int x =20;
//		while(true) {
//			int x= 20;
//			
//		}
		
//		while(true) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable Statement ");// Unreachable code
		
//		while(false) {// 	Unreachable code
//			System.out.println("Unreachable Statement");
//		}
//		System.out.println("reachable");
//		
		
//		int a=10;
//		int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Reachable code");
		
//		int a=10, b=20;
//		while(a>10) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");// Hii
		
		
//		final int a=10;
//		final int b=20;
//		while(a<b) {
//			System.out.println("Hello");
//		}
//		System.out.println("Unreachable code due to final variable");// Unreachable code
		
		
//		
//		final int a=10, b=20;
//		 while(a>10) {// Unreachable code
//
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
//		
//		 
//		do while() loop
//		boolean x =true;
//		 do;
//			 while(true);
		 
//		do
//			 System.out.println("Fahad");// Infinite do while loop
//		while(true);
//				
//		do;
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(false);
		
//		do
//			System.out.println("Fahad");
//		while(true);
		
//		do
//			System.out.println("Fahad");
//		while(true);
//			System.out.println("Fahad");
		
//		do
//			System.out.println("Fahad");// Syntax error, insert "while ( Expression ) ;" to complete BlockStatements
//			System.out.println("Fahad");
//		while(true);
		
//		do
//		{
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//			System.out.println("Fahad");
//		}
//		while(true);
		
//		do
//			int x= 10;
//		while(true);
		
//		do {
//			int x= 10;
//			System.out.println("Fahad");
//			System.out.println(x);
//		}
//		while(true);
		
//		do 
//			while(true)
//			System.out.println("Fahad");
//			while(false);
		
//		do
//			while(true)
//				System.out.println("true");
//		while(false);
		
//		Unreachability:-
		
//		do {
//			System.out.println("Hello !!");
//		}
//		while(true);
//		System.out.println("Fahad");// Unreachable code
		
//		do {
//			System.out.println("Hello!!");
//		}
//		while(false);
//		System.out.println("Hii!!");
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a<b);// true
//		System.out.println("Hii");
//		int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello");
//		
		
//		final int a=10, b=20;
//		do 
//		System.out.println("Hello");
//		while(a<b);
//		System.out.println("Hello"); // Unreachable code due to final a & b variable
		
		
//		int a=10, b=20;
//		do {
//			System.out.println("Hello");
//		}while(a>b);
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a<b);
//		System.out.println("hii'");// Unreachable code
		
//		final int a=10, b=20;
//		do {
//			System.out.println("hello");
//		}while(a>b);
//		System.out.println("hii'");
		
//		Lecture 28 :- for & for each loop
		
//		For Loop:-
//		If we know the number of iteration in advace then we can go for for loop
		
//		for(Initialization_Section;Condition_ceck;incre_decre_Section) {
//			loop body
//		}
//		
//		Steps of execution of for loop
		
//		1. initialization
//		2. condition check
//		3. execute loop body
//		3. incre-decrem section
//		5. condition check
//		6. execute loop body
//		7. incre-decrem section
//		8. condition check
//		9. execute loop body
		
//		eg: 
//		for(;true;) { // Infinite loop
//			System.out.println("fahad");
//		}
		
//		for(;;) {// Infinite loop
//			System.out.println("fahad");
//		}
  
//		for(int i=0; true;i++)// Infinite loop
//			System.out.println("Fahad");
		
//		for(int i=0;true;i++)
//			int x= 10;
//		Syntax error, insert ". class" to complete Expression
//		Syntax error, insert "AssignmentOperator Expression" to complete Assignment
//		Syntax error, insert ";" to complete Statement
//		The left-hand side of an assignment must be a variable
//		x cannot be resolved to a variable
		
//		for(int i=0;true;i++)
//			;
		
//		for(int i=0;true;i++);
		
//		for(int i=10;i<10;i++)
//			int z=10;
		
//		Initialization section:
		
//		for(int x=9,y=10,z=30;x<10;x++)
//			System.out.println("fahad");
		
//		for(int i=0, int j=0; i<10;i++)// Syntax error on token "int", delete this token
//			System.out.println("Fahad");
		
//		for(String S ="Fahad"; S=="Fahad"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", int x=10; S=="Fahad"; S="Ali")
//			System.out.println("fahad");// Syntax error on token "int", delete this token
										//Type mismatch: cannot convert from int to String
			
//		for(String S ="Fahad", K="Kite"; S=="Fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K="Kite"; S="Ali")
//			System.out.println("fahad");//The operator <= is undefined for the argument type(s) java.lang.String, java.lang.String
										//Syntax error on token "=", <= expected
		
		
//		for(String S ="Fahad", K="Kite"; S=="fahad"|| K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
		
//		for(String S ="Fahad", K="Kite"; S=="Fahad"&& K=="Kite"; S="Ali")
//			System.out.println("fahad");
		
//		int i=0;
//		for(System.out.println("Hello u are sleeping");i<3;i++)
//		{
//			System.out.println("No U are sleeping");
//		}
//		Hello u are sleeping
//		No U are sleeping
//		No U are sleeping
//		No U are sleeping
		
		
//		Condition check:-
//		we can take any valid java expression but shoul be of type boolean
//		This part is optional and if we are not anything then compiler by default will place true
		
//		eg:
//		for(int x=0;true;x++) {
//			System.out.println("hello");
//		}
		
//		Icrement?Decrement Section:
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			i++;
//		}
		
//		int i=0;
//		for(System.out.println("'hello 1");i<3;System.out.println("Hii 2")) {
//			
//		}
//		all three part of loop independent of each other and optional
//		for(;;) {
//			
//		}
//		for(;;) {
//			System.out.println("Hello");
//		}
		
//		for(;;);// infinite loop
		
//		for(System.out.println("Fahad");;);
		
//		Unreachability:
		
//		for(int i=0;true;i++) {
//			System.out.println("Accessible");
//		}
//		System.out.println("Non-Accessible");// Unreachable code
		
//		for(int i=0;false;i++) {
//			System.out.println("Non-Accessible");// Unreachable code
//		}
//		System.out.println("Accessible");
		
//		for(int i=0; ;i++) {// by default true
//			System.out.println("Reachable");
//		}
//		System.out.println("Unreachable code");
		
//		 int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("hii");
		
//		int a=10,b=20;
//		for(int i=10;a>b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
		
//		final int a=10, b=20;
//		for(int i=0;a<b;i++) {
//			System.out.println("Hello");
//		}
//		System.out.println("Hii");
		
//		final int a=10, b=20;
//		for(int i=0;a>b;i++) {
//			System.out.println("Hello");// Unreachable code
//		}
//		System.out.println("Hii");
		
//		For-Each Loop(Enhanced for loop)
//		Introduced in 1.5 v. specially designed for Arrays & Collection to retrive element of array and collection
		
//		Case 1:-
//		To print an element of 1-D Array
		
//		int[] x = {10,20,30,40};
		
//		Normal for loop
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println(x[i]);
//		}
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x+""+i+".."+x[i]);
//		}
		
//			  x[i]=[I@2c7b84de0..10
//		      x[i]=[I@2c7b84de1..20
//		      x[i]=[I@2c7b84de2..30
//		      x[i]=[I@2c7b84de3..40
		
//		for(int i=0;i<x.length;i++) {
//			System.out.println("x[i]="+x[i]);
//		}
		
//		for(int x1:x) {
//			System.out.println(x1);
//		}
		
//		To_Print element of 2_D Array
//		int[][] x = {{10,20,30},{40,50}};
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				System.out.println(x[i][j]);// 10,20,30,40,50
//			}
//		}
		
//		for(int[] x1 : x) {
//			for(int x2 : x1) {
//				System.out.println(x2);// 10,20,30,40,50
//			}
//		}
		
//		To print element of 3-D array
		
//		int[][][] x= {{{10,20},{30,40}},{{50,60,70},{80,90}}};
		
//		for(int x1[][]:x) {
//			for(int x2[]:x1) {
//				for(int x3:x2) {
//					System.out.println(x3);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<x.length;i++) {
//			for(int j=0;j<x[i].length;j++) {
//				for(int k=0;k<x[i][j].length;k++) {
//					System.out.println(x[i][j][k]);// 10,20,30,40,50, 60,70,80,90
//				}
//			}
//		}
		
//		for(int i=0;i<10;i++) {
//			System.out.println("No of Itearion :"+(i+1)+"   With value :"+i);
//		}
//		
//		we can write equivalent for each loop directly for above genral purpose for loop
//		
//		for(int  : x) {
//			System.out.println(); // not possible
//		}
		
//		int[] x = {10,20,30,40,50}; // print element in reverse order
//		for(int i=x.length-1;i>=0;i--) { 
//			System.out.println(x[i]);
//		}
		
//		int[] x= {10,20,30,40,50};
////		for(int x1 : x) {
////			System.out.println(x1);
////		}
//		for(int x1 : x) {
//			System.out.println(x1);
//			
//		}
		
//		Lecture 29: Break and continue  
//		Transfer Statement:
//		1. Break 
//		2. Continue
		
//		Trnafer statement is used ot trnafer the control from one place to another
		
//		 can use break inside switch to stop fall through
		
//		int x=0;
//		switch(x)
//		{
//		case 0:
//			System.out.println(0);// 0
//		case 1:
//			System.out.println(1);// 1
//			break;// 0,1
//		case 2:
//			System.out.println(2);
//		default:
//			System.out.println("def");
//		}
		
		
//		Inside loops: to break loop execution based on some condition:
		
//		for(int i=0;i<10;i++) {
//			if(i==5)
//				break;// 0,1,2,3,4 break means tootna aage nahi jaega.
//			System.out.println(i);
//		}
		
//		Inside lAbeled blocks:to break block execution based on some condition:
		
//		int x=10;
//		l1:{
//		System.out.println("begin");
//		if(x==10)
//			break l1;
//		System.out.println("end");
//		}
//		System.out.println("hello");
//		o/p begin, hello
		
//		byte b= 10;
//		l1:{
//			System.out.println("Begin Label");
//			if(b==10)
//				break l1;
//			System.out.println("END Label");
//			
//		}
//		System.out.println("Hello Label");// Begin Label, 	Hello Label
		
//		int x=10;
//		if(x==10)
//			break;
//		System.out.println("Hello");// break cannot be used outside of a loop or a switch
		
//		Continue statement: 
//		skip current iteration and continue next iteration
		
//		for(int i=0;i<10;i++) {
//			if(i%2==0)
//				continue;
//			System.out.println(i);// 1,3,5,7,9
//			
//		}
//		we can use continue statement pnly inside loop 
		
//		int x=10;
//		if(x==10)
//			continue;
//		System.out.println("hello");// continue cannot be used outside of a loop
		
//		Labelled Break & COntinue:
//		l1:{
//			for() {
//				l2:{
//					for() {
//						for() {
//							break l1;// See video
//							break l2;
//							break;
//						}
//					}
//				}
//			}
		
		
//		}
			
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 
//						continue l1;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P
//		1...0
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						continue;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
		
//		O/P:
//		0...1
//		0...2
//		1...0
//		1...2
//		2...0
//		2...1
		
//		l1:
//			for(int i=0;i<3;i++) {
//				for(int j=0;j<3;j++) {
//					if(i==j) 	
//						break;
//					System.out.println(i+"..."+j);
//					
//				}
//			}
//		O/P:
//		1...0
//		2...0
//		2...1
		
		l1:
			for(int i=0;i<3;i++) {
				for(int j=0;j<3;j++) {
					if(i==j) 	
						break l1;
					System.out.println(i+"..."+j);
					
				}
			}
		O/P

			
		
		
	
		
		
		
		
		
		
		
			
		
		
			
		

	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2023-02-21 00:23:00.667
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2023-02-21 00:23:00.669
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-02-21 17:26:11.010 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-02-21 17:26:20.971
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-21 17:26:20.971
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-21 17:26:20.971
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-21 17:26:31.472
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-02-22 12:21:51.207 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-02-22 12:21:55.649
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-02-22 12:22:01.074
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 12:22:01.074
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3add5e17,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1c58d7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-02-22 12:22:01.074
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@61b8c9de,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@b34c7c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-02-22 12:22:13.050
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-05 09:49:38.917 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-04-05 09:49:44.762
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-04-05 09:49:51.281
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-05 09:49:51.281
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@61b8c9de,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@b34c7c9,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-05 09:49:51.281
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@5b490d5e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@1f6c4ae,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-05 09:50:03.717
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-07 10:50:54.315 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-07 10:51:10.383
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 10:51:10.383
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-07 10:51:10.383
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-07 10:51:28.348
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-09 22:02:37.106 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-09 22:02:50.982
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-09 22:02:50.982
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@57b63253,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@c0013b8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-09 22:02:50.982
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-09 22:03:04.799
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-19 16:10:22.526 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-19 16:10:38.103
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 16:10:38.104
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@226e07e7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c31e410,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-19 16:10:38.104
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@9880a15,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6febec41,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-19 16:10:51.988
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-04-26 10:33:53.295 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-26 10:34:11.033
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-26 10:34:11.033
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-26 10:34:11.033
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@173a5fad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce47652,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-26 10:34:27.029
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.ui 4 0 2023-04-26 11:49:16.213
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4907)
	at org.eclipse.swt.SWT.error(SWT.java:4822)
	at org.eclipse.swt.SWT.error(SWT.java:4793)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:445)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:364)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3446)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setFocus(AbstractAnnotationHover.java:212)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformationControl(AbstractInformationControlManager.java:1246)
	at org.eclipse.jface.internal.text.StickyHoverManager.showInformationControl(StickyHoverManager.java:262)
	at org.eclipse.jface.internal.text.InformationControlReplacer.showInformationControl(InformationControlReplacer.java:164)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1134)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractInformationControlManager.setInformation(AbstractInformationControlManager.java:431)
	at org.eclipse.jface.internal.text.InformationControlReplacer.computeInformation(InformationControlReplacer.java:116)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformation(AbstractInformationControlManager.java:1091)
	at org.eclipse.jface.internal.text.InformationControlReplacer.replaceInformationControl(InformationControlReplacer.java:103)
	at org.eclipse.jface.text.AbstractInformationControlManager.replaceInformationControl(AbstractInformationControlManager.java:1268)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.replaceInformationControl(AbstractHoverInformationControlManager.java:794)
	at org.eclipse.jface.text.TextViewerHoverManager.replaceInformationControl(TextViewerHoverManager.java:297)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$Closer.lambda$1(AbstractHoverInformationControlManager.java:296)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)

!ENTRY org.eclipse.ui 4 0 2023-04-26 12:54:42.231
!MESSAGE Unhandled event loop exception
!STACK 0
org.eclipse.swt.SWTException: Widget is disposed
	at org.eclipse.swt.SWT.error(SWT.java:4907)
	at org.eclipse.swt.SWT.error(SWT.java:4822)
	at org.eclipse.swt.SWT.error(SWT.java:4793)
	at org.eclipse.swt.widgets.Widget.error(Widget.java:445)
	at org.eclipse.swt.widgets.Widget.checkWidget(Widget.java:364)
	at org.eclipse.swt.widgets.Control.setFocus(Control.java:3446)
	at org.eclipse.jdt.internal.ui.text.java.hover.AbstractAnnotationHover$AnnotationInformationControl.setFocus(AbstractAnnotationHover.java:212)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformationControl(AbstractInformationControlManager.java:1246)
	at org.eclipse.jface.internal.text.StickyHoverManager.showInformationControl(StickyHoverManager.java:262)
	at org.eclipse.jface.internal.text.InformationControlReplacer.showInformationControl(InformationControlReplacer.java:164)
	at org.eclipse.jface.text.AbstractInformationControlManager.internalShowInformationControl(AbstractInformationControlManager.java:1134)
	at org.eclipse.jface.text.AbstractInformationControlManager.presentInformation(AbstractInformationControlManager.java:1120)
	at org.eclipse.jface.text.AbstractInformationControlManager.setInformation(AbstractInformationControlManager.java:431)
	at org.eclipse.jface.internal.text.InformationControlReplacer.computeInformation(InformationControlReplacer.java:116)
	at org.eclipse.jface.text.AbstractInformationControlManager.doShowInformation(AbstractInformationControlManager.java:1101)
	at org.eclipse.jface.text.AbstractInformationControlManager.showInformation(AbstractInformationControlManager.java:1091)
	at org.eclipse.jface.internal.text.InformationControlReplacer.replaceInformationControl(InformationControlReplacer.java:103)
	at org.eclipse.jface.text.AbstractInformationControlManager.replaceInformationControl(AbstractInformationControlManager.java:1268)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager.replaceInformationControl(AbstractHoverInformationControlManager.java:794)
	at org.eclipse.jface.text.TextViewerHoverManager.replaceInformationControl(TextViewerHoverManager.java:297)
	at org.eclipse.jface.text.AbstractHoverInformationControlManager$Closer.lambda$1(AbstractHoverInformationControlManager.java:296)
	at org.eclipse.swt.widgets.RunnableLock.run(RunnableLock.java:40)
	at org.eclipse.swt.widgets.Synchronizer.runAsyncMessages(Synchronizer.java:185)
	at org.eclipse.swt.widgets.Display.runAsyncMessages(Display.java:4035)
	at org.eclipse.swt.widgets.Display.readAndDispatch(Display.java:3635)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine$5.run(PartRenderingEngine.java:1154)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.e4.ui.internal.workbench.swt.PartRenderingEngine.run(PartRenderingEngine.java:1045)
	at org.eclipse.e4.ui.internal.workbench.E4Workbench.createAndRunUI(E4Workbench.java:155)
	at org.eclipse.ui.internal.Workbench.lambda$3(Workbench.java:644)
	at org.eclipse.core.databinding.observable.Realm.runWithDefault(Realm.java:338)
	at org.eclipse.ui.internal.Workbench.createAndRunWorkbench(Workbench.java:551)
	at org.eclipse.ui.PlatformUI.createAndRunWorkbench(PlatformUI.java:156)
	at org.eclipse.ui.internal.ide.application.IDEApplication.start(IDEApplication.java:152)
	at org.eclipse.equinox.internal.app.EclipseAppHandle.run(EclipseAppHandle.java:203)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.runApplication(EclipseAppLauncher.java:136)
	at org.eclipse.core.runtime.internal.adaptor.EclipseAppLauncher.start(EclipseAppLauncher.java:104)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:401)
	at org.eclipse.core.runtime.adaptor.EclipseStarter.run(EclipseStarter.java:255)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:568)
	at org.eclipse.equinox.launcher.Main.invokeFramework(Main.java:659)
	at org.eclipse.equinox.launcher.Main.basicRun(Main.java:596)
	at org.eclipse.equinox.launcher.Main.run(Main.java:1467)
	at org.eclipse.equinox.launcher.Main.main(Main.java:1440)
!SESSION 2023-04-28 11:04:56.890 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-04-28 11:05:13.939
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-28 11:05:13.939
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-04-28 11:05:13.939
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@173a5fad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-04-28 11:05:28.883
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-02 12:15:01.711 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-05-02 12:15:14.709
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 12:15:14.709
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3de88f64,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4e8afdad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-02 12:15:14.709
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@79b8ecb,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3722f39d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-02 12:15:26.195
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-04 11:46:46.980 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-05-04 11:46:56.981
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-04 11:46:56.981
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-04 11:46:56.981
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@173a5fad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2ce47652,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-04 11:47:06.242
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-05-15 18:29:51.000 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.1
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-05-15 18:30:01.775
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-15 18:30:01.775
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2c1ea7be,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2493eec6,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-05-15 18:30:01.775
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@42d174ad,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4ec0229c,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-05-15 18:30:12.710
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-07-21 18:39:46.484 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-21 18:40:02.420
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-21 18:40:02.421
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-21 18:40:02.421
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-21 18:40:20.567
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:21.907
!MESSAGE Exception while reading last build state for: P/1_Java-Language_Fundamentals_Identifier-Arrays-1-5
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project 1_Java-Language_Fundamentals_Identifier-Arrays-1-5
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:21.910
!MESSAGE Error reading last build state for project 1_Java-Language_Fundamentals_Identifier-Arrays-1-5
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:22.085
!MESSAGE Exception while reading last build state for: P/2_Java_Language_Fundamentals_type_of_var_to_Java_Cdng_Standrd_6-10
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project 2_Java_Language_Fundamentals_type_of_var_to_Java_Cdng_Standrd_6-10
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:22.085
!MESSAGE Error reading last build state for project 2_Java_Language_Fundamentals_type_of_var_to_Java_Cdng_Standrd_6-10
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:22.670
!MESSAGE Exception while reading last build state for: P/3_Java_OperatorsAndAssingment
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project 3_Java_OperatorsAndAssingment
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:22.671
!MESSAGE Error reading last build state for project 3_Java_OperatorsAndAssingment
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:22.671
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:22.757
!MESSAGE Exception while reading last build state for: P/4_Java_Flow_Control
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project 4_Java_Flow_Control
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:22.758
!MESSAGE Error reading last build state for project 4_Java_Flow_Control
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:22.759
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:22.863
!MESSAGE Exception while reading last build state for: P/5_Java_Declaration_And_AccessModifier
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project 5_Java_Declaration_And_AccessModifier
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:22.864
!MESSAGE Error reading last build state for project 5_Java_Declaration_And_AccessModifier
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:23.665
!MESSAGE Exception while reading last build state for: P/Class_access
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Class_access
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:23.665
!MESSAGE Error reading last build state for project Class_access
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:23.887
!MESSAGE Exception while reading last build state for: P/Coding_Questions_on_CoreJava
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Coding_Questions_on_CoreJava
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:23.888
!MESSAGE Error reading last build state for project Coding_Questions_on_CoreJava
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:23.888
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:23.976
!MESSAGE Exception while reading last build state for: P/GFG_START_Basic_Java
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project GFG_START_Basic_Java
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:23.976
!MESSAGE Error reading last build state for project GFG_START_Basic_Java
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:23.976
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.061
!MESSAGE Exception while reading last build state for: P/Java_1.6
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Java_1.6
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.061
!MESSAGE Error reading last build state for project Java_1.6
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.119
!MESSAGE Exception while reading last build state for: P/Java_Basics
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Java_Basics
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.119
!MESSAGE Error reading last build state for project Java_Basics
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:24.119
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.201
!MESSAGE Exception while reading last build state for: P/Java_By_Durga_Soft
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Java_By_Durga_Soft
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.201
!MESSAGE Error reading last build state for project Java_By_Durga_Soft
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:24.202
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.293
!MESSAGE Exception while reading last build state for: P/Java_By_Durga_basics
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Java_By_Durga_basics
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.294
!MESSAGE Error reading last build state for project Java_By_Durga_basics
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.406
!MESSAGE Exception while reading last build state for: P/Java_Fundamentals_Coding_Questions
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project Java_Fundamentals_Coding_Questions
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.406
!MESSAGE Error reading last build state for project Java_Fundamentals_Coding_Questions
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.484
!MESSAGE Exception while reading last build state for: P/MainClass
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project MainClass
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.487
!MESSAGE Error reading last build state for project MainClass
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:24.763
!MESSAGE Exception while reading last build state for: P/New_Project
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project New_Project
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:24.764
!MESSAGE Error reading last build state for project New_Project
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:25.053
!MESSAGE Exception while reading last build state for: P/No_public_Class
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project No_public_Class
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:25.054
!MESSAGE Error reading last build state for project No_public_Class
!STACK 0
java.lang.NullPointerException: Cannot invoke "org.eclipse.jdt.internal.compiler.util.JrtFileSystem.walkModuleImage(org.eclipse.jdt.internal.compiler.util.JRTUtil$JrtFileVisitor, int)" because the return value of "org.eclipse.jdt.internal.compiler.util.JRTUtil.getJrtSystem(java.io.File, String)" is null
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.walkModuleImage(JRTUtil.java:173)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.loadModules(ClasspathJrt.java:127)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrt.<init>(ClasspathJrt.java:64)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:162)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2023-07-21 18:40:25.241
!MESSAGE Exception while reading last build state for: P/W3c_School_Java
!STACK 1
org.eclipse.core.runtime.CoreException: Error reading last build state for project W3c_School_Java
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4122)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	... 15 more
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 1 org.eclipse.jdt.core 4 2 2023-07-21 18:40:25.241
!MESSAGE Error reading last build state for project W3c_School_Java
!STACK 1
org.eclipse.core.runtime.CoreException: Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:80)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
Caused by: java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	... 20 more
!SUBENTRY 2 org.eclipse.jdt.core 4 0 2023-07-21 18:40:25.242
!MESSAGE Failed to init ct.sym for C:\Program Files\Java\jdk-17.0.1\lib\jrt-fs.jar
!STACK 0
java.io.FileNotFoundException: File C:\Program Files\Java\jdk-17.0.1\lib\ct.sym does not exist
	at org.eclipse.jdt.internal.compiler.util.CtSym.init(CtSym.java:127)
	at org.eclipse.jdt.internal.compiler.util.CtSym.<init>(CtSym.java:121)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.lambda$1(JRTUtil.java:136)
	at java.base/java.util.concurrent.ConcurrentHashMap.compute(ConcurrentHashMap.java:1916)
	at org.eclipse.jdt.internal.compiler.util.JRTUtil.getCtSym(JRTUtil.java:133)
	at org.eclipse.jdt.internal.core.builder.ClasspathJrtWithReleaseOption.<init>(ClasspathJrtWithReleaseOption.java:78)
	at org.eclipse.jdt.internal.core.builder.ClasspathLocation.forJrtSystem(ClasspathLocation.java:163)
	at org.eclipse.jdt.internal.core.builder.State.readBinaryLocations(State.java:378)
	at org.eclipse.jdt.internal.core.builder.State.read(State.java:266)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.readState(JavaBuilder.java:161)
	at org.eclipse.jdt.internal.core.JavaModelManager.readState(JavaModelManager.java:4117)
	at org.eclipse.jdt.internal.core.JavaModelManager.getLastBuiltState(JavaModelManager.java:2263)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.getLastState(JavaBuilder.java:449)
	at org.eclipse.jdt.internal.core.builder.JavaBuilder.build(JavaBuilder.java:189)
	at org.eclipse.core.internal.events.BuildManager$2.run(BuildManager.java:853)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:232)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:281)
	at org.eclipse.core.internal.events.BuildManager$1.run(BuildManager.java:334)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.core.internal.events.BuildManager.basicBuild(BuildManager.java:337)
	at org.eclipse.core.internal.events.BuildManager.basicBuildLoop(BuildManager.java:389)
	at org.eclipse.core.internal.events.BuildManager.build(BuildManager.java:410)
	at org.eclipse.core.internal.events.AutoBuildJob.doBuild(AutoBuildJob.java:160)
	at org.eclipse.core.internal.events.AutoBuildJob.run(AutoBuildJob.java:251)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2023-07-27 08:51:55.061 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-27 08:52:13.288
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-27 08:52:13.288
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@34a33343,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@98722ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-27 08:52:13.288
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@459e120b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@fd69983,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-27 08:52:41.944
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-07-31 16:36:08.127 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-07-31 16:36:23.244
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-31 16:36:23.244
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0e4e4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20231384,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-07-31 16:36:23.244
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-07-31 16:36:34.718
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-08-10 17:44:23.968 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-10 17:44:36.308
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-10 17:44:36.308
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-10 17:44:36.308
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-10 17:44:47.948
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-08-10 17:54:30.936 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-10 17:54:42.069
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-10 17:54:42.069
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20231384,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-10 17:54:42.069
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-10 17:54:53.027
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-08-18 16:24:33.088 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-18 16:24:42.896
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-18 16:24:42.897
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-18 16:24:42.897
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-18 16:24:53.008
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-08-18 16:25:45.154 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-18 16:25:54.169
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-18 16:25:54.169
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0e4e4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20231384,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-18 16:25:54.169
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-18 16:26:02.559
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-08-29 00:45:12.204 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-08-29 00:45:22.236
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-29 00:45:22.236
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@495da9a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2beee3e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-08-29 00:45:22.237
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@732d078d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58bad46f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-08-29 00:45:31.720
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-10 01:16:44.062 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-10 01:16:55.856
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-10 01:16:55.856
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2beee3e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@732d078d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-10 01:16:55.856
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58bad46f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0e4e4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-10 01:17:06.903
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-10 17:37:27.337 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-10 17:37:37.953
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-10 17:37:37.954
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-10 17:37:37.954
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-10 17:37:48.618
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-12 12:20:41.822 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-12 12:20:52.115
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-12 12:20:52.115
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20231384,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-12 12:20:52.115
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-12 12:21:02.919
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.net 1 0 2023-09-12 12:21:03.609
!MESSAGE System property http.proxyHost is set to proxy.cognizant.com but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-12 12:21:03.611
!MESSAGE System property http.proxyPort is set to 6050 but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-12 12:21:03.613
!MESSAGE System property https.proxyHost is set to proxy.cognizant.com but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-12 12:21:03.616
!MESSAGE System property https.proxyPort is set to 6050 but should not be set.
!SESSION 2023-09-13 16:56:51.226 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-13 16:57:05.464
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-13 16:57:05.465
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30fa8a6b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f112f70,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-13 16:57:05.465
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@342723a3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f3876ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-13 16:57:19.896
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.net 1 0 2023-09-13 16:57:22.251
!MESSAGE System property http.proxyHost is set to proxy.cognizant.com but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-13 16:57:22.253
!MESSAGE System property http.proxyPort is set to 6050 but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-13 16:57:22.255
!MESSAGE System property https.proxyHost is set to proxy.cognizant.com but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-13 16:57:22.257
!MESSAGE System property https.proxyPort is set to 6050 but should not be set.
!SESSION 2023-09-20 11:00:48.898 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-20 11:00:58.527
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 11:00:58.528
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 11:00:58.528
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-20 11:01:09.315
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.net 1 0 2023-09-20 11:01:10.101
!MESSAGE System property http.proxyHost is set to proxy.cognizant.com but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-20 11:01:10.103
!MESSAGE System property http.proxyPort is set to 6050 but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-20 11:01:10.106
!MESSAGE System property https.proxyHost is set to proxy.cognizant.com but should not be set.

!ENTRY org.eclipse.core.net 1 0 2023-09-20 11:01:10.108
!MESSAGE System property https.proxyPort is set to 6050 but should not be set.
!SESSION 2023-09-20 16:09:10.173 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-20 16:09:20.556
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 16:09:20.556
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-20 16:09:20.556
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-20 16:09:31.068
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-21 16:34:55.711 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-21 16:35:08.768
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-21 16:35:08.768
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-21 16:35:08.768
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30fa8a6b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-21 16:35:21.990
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-28 09:37:20.093 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-28 09:37:32.733
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-28 09:37:32.733
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@495da9a7,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2beee3e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-28 09:37:32.733
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@732d078d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58bad46f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-28 09:37:45.615
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-09-30 16:41:19.836 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-09-30 16:41:29.081
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-30 16:41:29.081
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-09-30 16:41:29.081
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-09-30 16:41:38.522
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-01 12:29:26.023 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-10-01 12:29:38.656
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-01 12:29:38.656
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-01 12:29:38.656
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30fa8a6b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f112f70,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-01 12:29:52.344
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-03 07:59:55.679 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-10-03 08:00:13.077
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-03 08:00:13.078
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f112f70,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@342723a3,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-03 08:00:13.078
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@f3876ef,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6b751cb1,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-03 08:00:29.006
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-04 12:33:14.000 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-10-04 12:33:25.872
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-04 12:33:25.872
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-04 12:33:25.872
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-04 12:33:38.028
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-17 20:55:02.372 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-10-17 20:55:18.667
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-17 20:55:18.667
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-17 20:55:18.667
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-17 20:55:49.103
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-18 20:33:01.820 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-10-18 20:33:16.516
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-18 20:33:16.516
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-18 20:33:16.516
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-18 20:33:32.758
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-19 13:05:31.398 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-10-19 13:05:41.544
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-19 13:05:41.544
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-19 13:05:41.544
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30fa8a6b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f112f70,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-19 13:05:51.846
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-10-31 20:24:31.699 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.core.resources 2 10035 2023-10-31 20:24:40.265
!MESSAGE The workspace exited with unsaved changes in the previous session; refreshing workspace to recover changes.

!ENTRY org.eclipse.jface 2 0 2023-10-31 20:24:49.983
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-31 20:24:49.983
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@4b336cc8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2570b316,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-10-31 20:24:49.983
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@56881196,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@75c33608,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-10-31 20:25:12.375
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-11-18 12:32:33.927 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-11-18 12:32:52.378
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-18 12:32:52.378
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-18 12:32:52.378
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-18 12:33:17.899
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-11-20 23:07:31.858 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-11-20 23:07:48.670
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 23:07:48.670
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-11-20 23:07:48.670
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@30fa8a6b,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@6f112f70,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-11-20 23:08:26.325
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-12-16 16:49:36.947 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-12-16 16:49:47.736
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-16 16:49:47.736
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-16 16:49:47.736
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@73d91faf,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-16 16:49:58.282
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-12-25 15:51:42.360 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-12-25 15:51:54.129
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-25 15:51:54.129
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@2beee3e8,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@732d078d,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-25 15:51:54.129
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@58bad46f,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0e4e4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-25 15:52:05.061
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.core.resources 2 2 2023-12-25 16:02:49.359
!MESSAGE Save operation warnings.
!SUBENTRY 1 org.eclipse.core.resources 2 234 2023-12-25 16:02:49.359
!MESSAGE The project description file (.project) for '1.1_Java-Fundamentals-Durgasoft-Practice' was missing.  This file contains important information about the project.  A new project description file has been created, but some information about the project may have been lost.
!SESSION 2023-12-27 17:30:27.909 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-12-27 17:30:38.220
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-27 17:30:38.220
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-27 17:30:38.220
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-27 17:30:48.663
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-12-27 18:34:48.047 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-12-27 18:35:06.256
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-27 18:35:06.257
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@7c0e4e4e,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20231384,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-27 18:35:06.257
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-27 18:35:34.368
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.
!SESSION 2023-12-31 18:01:23.321 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2023-12-31 18:01:42.391
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-31 18:01:42.391
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2023-12-31 18:01:42.391
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3cb04dd,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2023-12-31 18:02:00.610
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-01-01 01:12:39.849
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList; 
	
public class OperatorsAndAssingments_Practice {
	//class Customer{
//	
//}
//class Test{
//	public static void main(String[] args)throws Exception {
//		Object O = Class.forName(args[0]).newInstance();
//		System.out.println("Object created for :"+O.getClass().getName());
////		System.out.println("Hello");
//- Other rest thing are thoery based and need setting for runnig in run time nad compile time seperately
//	}
//}
	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		Pre Increment
//		int x= 10;
//		int y= ++x;// pre incr -- here y value = 11
//		System.out.println(x);// 11
//		System.out.println(y);// 11
		
//		Post Increment
//		int x= 10;
//		int y= x++;
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		
//		int x= 10;
//		int y= x+1;
//		System.out.println(x);// 10
//		System.out.println(y);// 11
		
//		Pre Decrement
//		int x= 10;
//		int y= --x;
//		System.out.println(y);// 9
//		System.out.println(x);// 9
		
//		Post Decrement
//		int x= 10;
//		int y= x--;
//		System.out.println(y);// 10
//		System.out.println(x);// 9
		
//		int x= 10;
//		int y= ++10;// Invalid argument to operation ++/--
//		System.out.println(x);
////		System.out.println(y);
//		int z = 10++;// Invalid argument to operation ++/--
//		System.out.println(z);
		
		
//		int x= 10;
//		int y= ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		final int x = 10;
//		x++;// The final local variable x cannot be assigned. 
////		It must be blank and not using a compound assignment
//		System.out.println(x);
		
		
//		final int x = 10;
//		x++;
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
		
//		int x = 10;
//		x++;
//		System.out.println(x);
		
//		int x= 10;
//		int y= x++;
//		int z = x;
//		z++;
//		
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		System.out.println(z);// 12
		
//		int x = 10;
//		int y = ++x;
//		int z= y;
//		System.out.println(z);// 11
//		z++;
//		System.out.println(y);// 11
//		System.out.println(x);// 11
//		System.out.println(z);// 12
	
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		double d = 10.5;
//		++d;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;// Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		char ch = 'a';
//		char y = ch++;
//		System.out.println(ch);//b
//		System.out.println(y);//a
		
		
		
		
		
//		Diff Btwen b++ and b=b+1
		
//		byte b = 10;
//		byte a= 10;
//		byte c= a+b;// max(int,type of a, type of b)--> max(int,byte,byte)
//		System.out.println(c);//Type mismatch: cannot convert from int to byte
		
//		byte a = 10;
//		byte b = -1;
//		byte c= (byte)(a+b);
//		System.out.println(c);//9
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = a+b;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		int b = 10;
//		int a= 10;
//		int c = a+b; // max(int,type of a, type of b)--> max(int,int,int)
//		System.out.println(c);// 20
		
//		short a = 10;
//		short b = 10;
//		short c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to short
		
//		short a = 10;
//		short b = 10;
//		short c = (short)(a+b);
//		System.out.println(c);// 20
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = ch + ch1;
//		System.out.println(chs);// Type mismatch: cannot convert from int to char
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = (char)(ch + ch1);
//		System.out.println(chs);//
		
//		char ch2 = '';
//		int in = ch2+0;
//		System.out.println(in);
		
		
//		char ch = 'a';
//		char ch1 = 'b';
//		int x = ch;
//		int y= ch1;
//		System.out.println(x);//97
//		System.out.println(y);//98
		
//		char x = 'a';
//		char y= 'b';
//		long l = x+y;
//		System.out.println(l);// 197
		
//		char x= 'a';
//		char y='b';
//		float f= x+y;
//		System.out.println(f);// 195.0
		
//		char x= 'a';
//		char y='b';
//		double d= x+y;
//		System.out.println(d);// 195.0
		
//		char ch = 'a';
//		double d = 10.5d;
//		double sum = ch +d;
//		System.out.println(sum);// 107.5
		
//		char ch = 'a';
//		double d = 10.5d;
//		int sum = (int)(ch +d);
//		System.out.println(sum);// 107
		
		
		
		
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = (byte)(a+b);// Type mismatch: cannot convert from int to byte
//		System.out.println(c);// 20
		
//		byte b= 10;
//		byte a = 20;
//		byte c = a + b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		byte b= 10;
//		byte a = 20;
//		byte c = (byte)(a + b);
//		System.out.println(c);
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b= (byte)(b+1+b);
//		System.out.println(b);// 21
		
//		byte b = 10;
//		b= (byte)(b+1+b-b+10-12);
//		System.out.println(b);// 9
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b =20;
//		b= b+1;
//		System.out.println(b);
		
//		byte c = 20;
//		c= c++;
//		System.out.println(c);//20
		
		
//		int a = 10;
//		int c = 10;
//		byte z = (byte)(a+c);
//		System.out.println(z);
		
		
		
//		int x= 10;
//		int y = ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		int x= 10;
//		int y= ++ (++x);
//		System.out.println(y);// Invalid argument to operation ++/--
		
		
		
		
		
//		byte c = 20;
//		byte z = c++;
//		System.out.println(z);//20
		
//		byte b = 10;
//		b++;// (byte)b+1
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11
		
		
		
		
//		2. Arithematic Operator - (+,-,*,/,%)
		
//		byte b = 10;
//		byte c = 19;
//		byte sum = (byte)(b+c) ;
//		System.out.println(sum);// 29
		
		
//		byte b = 10;
//		short s = 19;
//		short sum = (short)(b+s);
//		System.out.println(sum);// 29
		
//		short s1 = 10;
//		short s2= 18;
//		short sum = (short)(s1+s2);
//		System.out.println(sum);// 28
		
//		byte b = 10;
//		long l = 19;
//		long sum = b+l;
//		System.out.println(sum);// 29  -- int to long conversion is possible 
		
//		long l = 10;
//		double d = 10.4;
//		double sum = l+d;
//		System.out.println(sum);// 20.4 -- int to double is possible and long is max among
		
		
//		float f = 10.4f;
//		long l = 10;
//		long sum = f+l;// Type mismatch: cannot convert from float to long
//		long sum = (long)(f+l);// 20-- ans in long
//		float sum = l+f;// 20.4
//		System.out.println(sum);
		
//		char ch = 'A';
//		char ch1 = 'B';
//		char sum = ch+ch1;// Type mismatch: cannot convert from int to char
//		int sum = ch+ch1;
//		System.out.println(sum);// 131
		
//		char ch = 'A';
//		double d = 10.5;
//		int sum = ch+d;// Type mismatch: cannot convert from double to int
//		char sum1 = ch+d;// Type mismatch: cannot convert from double to char
//		double sum = ch+d;// 75.5
//		System.out.println(sum);

//		System.out.println('a'+'b');//195
//		System.out.println('a'+10.5);// 107.5
//		System.out.println('a'+0.89);// 97.89
		
//		System.out.println(10/0);// java.lang.ArithmeticException: / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(-10/0.0);// -Infinity
		
//		System.out.println(10/0.0f);// Infinity
//		System.out.println(-10/0.0f);// -Infinity
		
//		System.out.println(10/0);// / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(10.0/0);// Infinity
//		System.out.println(-10.0/0);// -Infinity
		
		
		
//		 NaN- Not a Number
		
//		System.out.println(0/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(0/29);//0
		
//		System.out.println(0/0.0f);// NaN
//		System.out.println(-0/0.0f);// NaN
		
//		System.out.println(0/0.0);// NaN
//		System.out.println(-0/0.0);// NaN
	
//		System.out.println(0/0);//java.lang.ArithmeticException: / by zero
		
//		System.out.println(0.0/0);// NaN
//		
//		System.out.println(-0.0/0);// NaN
		
//		Summary
		
//		System.out.println(10/0); / by zero
//		System.out.println(10/0.0);// Infinity
//		System.out.println(0/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(0.0/0);// NaN
		
//		System.out.println(10<Float.NaN);// false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN == Float.NaN);// false
//		System.out.println(10 != Float.NaN);// true
//		System.out.println(Float.NaN != Float.NaN);// true
		
		// need to study further on NaN 
		
		
		
//		2. String Concatenation operator:(+) lecture 18
		
//		String a = "Fahad";
//		int b=10,c=20,d=30;
//		System.out.println(a+b+c+d);// Fahad102030
//		System.out.println(b+c+d+a);// 60Fahad
//		System.out.println(b+c+a+d);// 30Fahad30
//		System.out.println(b+a+c+d);// 10Fahad2030
		
//		System.out.println(a=a+b+c);//Fahad1020
//		System.out.println(a=b+c+d);// Type mismatch: cannot convert from int to String
//		System.out.println(b=a+c+d);// Type mismatch: cannot convert from String to int
//		System.out.println(b=b+c+d);// 60
		
//		4. relational Operator (<,<=,>,>=)
//		System.out.println(10<20);// true
//		System.out.println('a'<20);//false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'<'A');// false
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		System.out.println("fahad102">"fahad");//The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5. Equality operator (==, !=)
		
		
	
		
		
//		--------Revision Practice -----------------------------------------------------------------------------
		
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
//		
//		int x= 10;
//		int y = ++x;
//		System.out.println(y);
//		int z = x++;
//		System.out.println(z);
//		int m = x++;
//		System.out.println(m);
		
		
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
//		
//		int x= 30;
//		int y= x++;
//		int z= ++x;
//		System.out.println(y); // 30
//		System.out.println(x); // 32
		
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
//		int x= 90;
//		int y= x++;
//		System.out.println(x);// 91
//		int y= ++x; //91
//		System.out.println(y);// 90
		
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
		
//		int x= 10;
//		int y= --x;
//		int z = x--;
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
		
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
//		int x= 10;
//		int y= 10++:
//		System.out.println(y);
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
		
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
		
//		int x= 10;
//  	int y= ++(x);
//		int z= ++(++x); // neasting of increment and decrement operators is not allowed.
//		System.out.println(z);
//		++x means value not a variable.. here we required variable not a valuex.
		
		
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		
//		final int x= 10;
//		int y = x++;
//		System.out.println(y);
		
		//The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
//		final int x= 10;
//		x=11;
//		System.out.println(x);
		
		
		
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
		
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
		
		
		
		
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // first assigned then increment.
//		
//		final int x= 10;
//		int y= x++;
//		System.out.println(y);
		
		
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
		
//		char ch = 'a';// a=97
//		ch++;
//		int y=ch;
//		System.out.println(ch);// b  becz value of a is 97 so after increment value becomes 98 which is value of b
//		System.out.println(y);// 98
		
//		double d= 10.9;
//		d++;
//		System.out.println(d);// 11.9
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
		
//		boolean b = false;
//		b++;// b+1-- (false+1)  Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		boolean b = false;
//		System.out.println(b);
		
		
		
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for every primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
		
//		If we applied any arithemetic operators between two variable a and b then
		//the result type is always	max of (int,type of a, type of b)
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+ b;// Type mismatch: cannot convert from int to byte
//		byte c= (byte) (a+b);
//		System.out.println(c);// 30
		
		
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
		
//		byte b =10;
//		b= b+1;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b=(byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11

//		byte b = 10;
//		b++;// internal typecasting happen by default
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr operator internal TypeCasting perform automatically
//		
//		byte b = 10;
//		byte c = 20;
//		byte d =(byte) (b+c);
//		System.out.println(d);// 30
		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->		float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97+0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(10/0);/ by zero
	
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two constatnt.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		System.out.println(10/0.0);
//		System.out.println(10.0/0.0);
//		System.out.println(10/-0.0);
//		System.out.println(-10/0.0);
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// / by zero
		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		System.out.println(10<Float.NaN);// false
		
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it is said arithmetic addition operators 
//		and sometime it is said string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
		
//		String a = "fahad";
//		int b=10,c=20,d=10;
//		System.out.println(a+b+c+d);//
//		System.out.println(b+c+d+a);
//		System.out.println(b+c+a+d);
//		System.out.println(b+a+c+d);
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		String a= "fahad";
//		int b=10, c=20, d=30;
////		a=b+c+d;
////		System.out.println(a);//Type mismatch: cannot convert from int to String
//		a=a+b+c;
////		System.out.println(a);
////		b=a+c+d;
//		b=b+c+d;
//		System.out.println(b);//60
		
		
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for every primitive type except boolean.
//		eg:-
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
//		
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'>'A');// true
//		System.out.println(true<false);
		
//		System.out.println(10<=10);// true
//		System.out.println(10>=10);// true
		
		
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println("fahad">"fahad");
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		System.out.println(10<20>30);// The operator > is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type including boolean also.
		
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
//		System.out.println(10==10);
//		System.out.println(10==20);
//		System.out.println('a'==97.0);
//		System.out.println('a'==97);
//		System.out.println('a'=='a');
//		System.out.println(false==false);// true
//		System.out.println('a'=='A');// false
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3 = t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);
//		System.out.println(O==S);
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
		
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1!=O);// true
//		System.out.println(O!=S);// true
//		System.out.println(S!=t1);// Incompatible operand types String and Thread
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		String S1 = new String("fahad");
//		String S2 = new String("fahad");
//		System.out.println(S1==S2);// false - address compare ho raha
//		System.out.println(S1.equals(S2)); // content/value compare ho rahi
//		
		
		
//		for any object reference r == null is always false
//		but null == null is always true
		
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		
//		String s = new String("durga");
//		System.out.println(s==null);// flase-- address compare and not matched so result is false.
		
//		String n = null;
//		System.out.println(n==null);// true.
//		System.out.println(null==null);// true
		
		
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to check whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);
//		System.out.println(t instanceof Object);
//		System.out.println(t instanceof Runnable);
		
//		int[] l = new int[9];
//		System.out.println(l[0]);
//		Object o = new l.get[0];
		
	
//		 ArrayList<String> l = new ArrayList<String>(); 
//		// Create an ArrayList object
//		 Object O = new l.get[0];
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		Thread t = new Thread();
//		System.out.println(t instanceof String);// Incompatible conditional operand types Thread and String
		
//		System.out.println(null instanceof Thread);// false
//		System.out.println(null instanceof Object);// false
//		System.out.println(null instanceof Runnable);// false
		
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		System.out.println(true & false); // false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false);// true
//		System.out.println(true ^ true);// false	
//		System.out.println(false ^ false);// false
		
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
//		System.out.println( 4 & 5);
//		System.out.println(4 |5);
//		System.out.println(4 ^ 5);
		
//		System.out.println(100 & 101);// 100
//		System.out.println(11 & 11); // 11
		
//		System.out.println(~4);// -5
		
//		System.out.println(~5);// -6
		
//		System.out.println(~38); // -39
		
		
		 
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		System.out.println(!10);
//		System.out.println(!true);
//		System.out.println(!false);
		
		
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
		
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
//		int x = 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		int x = 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16

//		int x = 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 & (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 | (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 | (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 || (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is responsible to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
//		int x= 'a';
//		System.out.println(x);// 97
//		
//		double d = 10;
//		System.out.println(d);// 10.0
		
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		float f = 10;
//		System.out.println(f);// 10.0
		
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		double d = 'a';
//		System.out.println(d);// 97.0
		
//		long l = 'a';
//		System.out.println(l);// 97
		
//		float f = 'a';
//		System.out.println(f);// 97.0
		
		
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		int x = 130;
//		byte b = (byte) x; //  cannot convert from int to byte
//		System.out.println(b);// -126
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
//		
//		int x = 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		int x = 150;
//		byte b= (byte)x;
//		System.out.println(b);// -106
		
//		int x = 509;
//		byte b = (byte)x;
//		System.out.println(b);// -3
		
//		int x = 509;
//		short s = (short)x;
//		System.out.println(s);// 509
		
		
		
		
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
		
//		double d = 130.456;
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		float f = 130.456f;
//		int x = (int)f;
//		System.out.println(x);// 130
		
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
//		int x = 10;
//		literal value 10 assigned to  var x
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
		
//		int a,b,c,d;
//		a=b=c=d=10;
//		System.out.println(a+".."+b+".."+c+".."+d);//10..10..10..10

//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);//20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator then we called that operator is CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		int a = 20;
//		a+=30;// -- a=a+30;
//		System.out.println(a);// 50

//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		byte b =10;
//		b=b+1;// cannot convert from int to byte
//		System.out.println(b);
//		
		
//		byte b = 10;
//		b++;
//		System.out.println(b);// 11

//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b =10;
//		b+=1; // b=b+1 
//		System.out.println(b);// 11

//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b =127;
//		b+=1;
//		System.out.println(b);// -128
		
//		byte b = 127;
//		b+=127;
//		System.out.println(b);//-2
		
//		byte b =127;
//		b+=129;
//		System.out.println(b);//0
		
//		byte b =127;
//		b+=130;
//		System.out.println(b);//1

//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		int a,c;
//		int b=20;
//		int d;
//		a=c=d=20;//chained
//		a+= 10;
//		b-=5;
//		c*=4;
//		d/=7;
//		System.out.println(a+"..."+b+"..."+c+"..."+d);//30...15...80...2
		
//		int a=10;
//		a+=a+10;
//		System.out.println(a);//30
		
//		int a=10;
//		a+=a+=a+=a-+a-+30;
//		System.out.println(a);
		
//		int a=10;
//		a+=12+12;
//		System.out.println(a);//34

//		int a,b,c,d,e,f,g,h;
//		a=b=c=d=e=f=g=h=10;
//		a+=10;
//		b-=10;
//		c/=10;// return quotient
//		d*=10;
//		e%=10; // return reminder
//		
//		f&=10; // f&10==> 10&10 = Ans 10 - 1010&1010==1010=10
//		g|=10; // 
//		h^=10;// x-OR cap 
//		
//		System.out.println(a); // 20
//		System.out.println(b); // 0
//		System.out.println(c); // 1
//		System.out.println(d); // 100
//		System.out.println(e); /// 0
//		System.out.println(f); // 10
//		System.out.println(g);// 10
//		System.out.println(h); // 0
		
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
		
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
		
		int x (10<20)
		
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
//	    1+2*3/4+5*6*7/8+9-10
		
//		If multiple operator has same precedence then it execute from left to right
//		and right to left accrdng to associativity.
		
//		For more detail : See Java operator precedence table
		
//		Lecture 23 : 
//		16.new vs newInstance()
//		1.new : - We can use this new operator to create an object , if we know classname at the beggining
//		eg:- 
//		Test t = new Test();
//		Student S = new Student();
//		Customer C = new Customer();
		
//		2. newInstance():- is a method in Class.class we can use newInstance method to create ibject, if we don't
//		 know class name at begginig and it is available sdynamically at runtime from
//		CLA,file,database.
//		eg: above
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError
//		both above 17 & 18 point are theory based and interview question only 
		
		
		
		


	}
//	public static int m1(int i) {
//	System.out.println(i);// 1,2,3,4,5,6
//	System.out.println(i);//1,2,3,4,5,6.7,8,9,10
//	return i;
//}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-01-01 01:12:39.856
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-01-01 01:12:39.858
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-01-01 01:12:39.943
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList; 
	
public class OperatorsAndAssingments_Practice {
	//class Customer{
//	
//}
//class Test{
//	public static void main(String[] args)throws Exception {
//		Object O = Class.forName(args[0]).newInstance();
//		System.out.println("Object created for :"+O.getClass().getName());
////		System.out.println("Hello");
//- Other rest thing are thoery based and need setting for runnig in run time nad compile time seperately
//	}
//}
	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		Pre Increment
//		int x= 10;
//		int y= ++x;// pre incr -- here y value = 11
//		System.out.println(x);// 11
//		System.out.println(y);// 11
		
//		Post Increment
//		int x= 10;
//		int y= x++;
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		
//		int x= 10;
//		int y= x+1;
//		System.out.println(x);// 10
//		System.out.println(y);// 11
		
//		Pre Decrement
//		int x= 10;
//		int y= --x;
//		System.out.println(y);// 9
//		System.out.println(x);// 9
		
//		Post Decrement
//		int x= 10;
//		int y= x--;
//		System.out.println(y);// 10
//		System.out.println(x);// 9
		
//		int x= 10;
//		int y= ++10;// Invalid argument to operation ++/--
//		System.out.println(x);
////		System.out.println(y);
//		int z = 10++;// Invalid argument to operation ++/--
//		System.out.println(z);
		
		
//		int x= 10;
//		int y= ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		final int x = 10;
//		x++;// The final local variable x cannot be assigned. 
////		It must be blank and not using a compound assignment
//		System.out.println(x);
		
		
//		final int x = 10;
//		x++;
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
		
//		int x = 10;
//		x++;
//		System.out.println(x);
		
//		int x= 10;
//		int y= x++;
//		int z = x;
//		z++;
//		
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		System.out.println(z);// 12
		
//		int x = 10;
//		int y = ++x;
//		int z= y;
//		System.out.println(z);// 11
//		z++;
//		System.out.println(y);// 11
//		System.out.println(x);// 11
//		System.out.println(z);// 12
	
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		double d = 10.5;
//		++d;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;// Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		char ch = 'a';
//		char y = ch++;
//		System.out.println(ch);//b
//		System.out.println(y);//a
		
		
		
		
		
//		Diff Btwen b++ and b=b+1
		
//		byte b = 10;
//		byte a= 10;
//		byte c= a+b;// max(int,type of a, type of b)--> max(int,byte,byte)
//		System.out.println(c);//Type mismatch: cannot convert from int to byte
		
//		byte a = 10;
//		byte b = -1;
//		byte c= (byte)(a+b);
//		System.out.println(c);//9
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = a+b;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		int b = 10;
//		int a= 10;
//		int c = a+b; // max(int,type of a, type of b)--> max(int,int,int)
//		System.out.println(c);// 20
		
//		short a = 10;
//		short b = 10;
//		short c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to short
		
//		short a = 10;
//		short b = 10;
//		short c = (short)(a+b);
//		System.out.println(c);// 20
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = ch + ch1;
//		System.out.println(chs);// Type mismatch: cannot convert from int to char
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = (char)(ch + ch1);
//		System.out.println(chs);//
		
//		char ch2 = '';
//		int in = ch2+0;
//		System.out.println(in);
		
		
//		char ch = 'a';
//		char ch1 = 'b';
//		int x = ch;
//		int y= ch1;
//		System.out.println(x);//97
//		System.out.println(y);//98
		
//		char x = 'a';
//		char y= 'b';
//		long l = x+y;
//		System.out.println(l);// 197
		
//		char x= 'a';
//		char y='b';
//		float f= x+y;
//		System.out.println(f);// 195.0
		
//		char x= 'a';
//		char y='b';
//		double d= x+y;
//		System.out.println(d);// 195.0
		
//		char ch = 'a';
//		double d = 10.5d;
//		double sum = ch +d;
//		System.out.println(sum);// 107.5
		
//		char ch = 'a';
//		double d = 10.5d;
//		int sum = (int)(ch +d);
//		System.out.println(sum);// 107
		
		
		
		
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = (byte)(a+b);// Type mismatch: cannot convert from int to byte
//		System.out.println(c);// 20
		
//		byte b= 10;
//		byte a = 20;
//		byte c = a + b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		byte b= 10;
//		byte a = 20;
//		byte c = (byte)(a + b);
//		System.out.println(c);
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b= (byte)(b+1+b);
//		System.out.println(b);// 21
		
//		byte b = 10;
//		b= (byte)(b+1+b-b+10-12);
//		System.out.println(b);// 9
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b =20;
//		b= b+1;
//		System.out.println(b);
		
//		byte c = 20;
//		c= c++;
//		System.out.println(c);//20
		
		
//		int a = 10;
//		int c = 10;
//		byte z = (byte)(a+c);
//		System.out.println(z);
		
		
		
//		int x= 10;
//		int y = ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		int x= 10;
//		int y= ++ (++x);
//		System.out.println(y);// Invalid argument to operation ++/--
		
		
		
		
		
//		byte c = 20;
//		byte z = c++;
//		System.out.println(z);//20
		
//		byte b = 10;
//		b++;// (byte)b+1
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11
		
		
		
		
//		2. Arithematic Operator - (+,-,*,/,%)
		
//		byte b = 10;
//		byte c = 19;
//		byte sum = (byte)(b+c) ;
//		System.out.println(sum);// 29
		
		
//		byte b = 10;
//		short s = 19;
//		short sum = (short)(b+s);
//		System.out.println(sum);// 29
		
//		short s1 = 10;
//		short s2= 18;
//		short sum = (short)(s1+s2);
//		System.out.println(sum);// 28
		
//		byte b = 10;
//		long l = 19;
//		long sum = b+l;
//		System.out.println(sum);// 29  -- int to long conversion is possible 
		
//		long l = 10;
//		double d = 10.4;
//		double sum = l+d;
//		System.out.println(sum);// 20.4 -- int to double is possible and long is max among
		
		
//		float f = 10.4f;
//		long l = 10;
//		long sum = f+l;// Type mismatch: cannot convert from float to long
//		long sum = (long)(f+l);// 20-- ans in long
//		float sum = l+f;// 20.4
//		System.out.println(sum);
		
//		char ch = 'A';
//		char ch1 = 'B';
//		char sum = ch+ch1;// Type mismatch: cannot convert from int to char
//		int sum = ch+ch1;
//		System.out.println(sum);// 131
		
//		char ch = 'A';
//		double d = 10.5;
//		int sum = ch+d;// Type mismatch: cannot convert from double to int
//		char sum1 = ch+d;// Type mismatch: cannot convert from double to char
//		double sum = ch+d;// 75.5
//		System.out.println(sum);

//		System.out.println('a'+'b');//195
//		System.out.println('a'+10.5);// 107.5
//		System.out.println('a'+0.89);// 97.89
		
//		System.out.println(10/0);// java.lang.ArithmeticException: / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(-10/0.0);// -Infinity
		
//		System.out.println(10/0.0f);// Infinity
//		System.out.println(-10/0.0f);// -Infinity
		
//		System.out.println(10/0);// / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(10.0/0);// Infinity
//		System.out.println(-10.0/0);// -Infinity
		
		
		
//		 NaN- Not a Number
		
//		System.out.println(0/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(0/29);//0
		
//		System.out.println(0/0.0f);// NaN
//		System.out.println(-0/0.0f);// NaN
		
//		System.out.println(0/0.0);// NaN
//		System.out.println(-0/0.0);// NaN
	
//		System.out.println(0/0);//java.lang.ArithmeticException: / by zero
		
//		System.out.println(0.0/0);// NaN
//		
//		System.out.println(-0.0/0);// NaN
		
//		Summary
		
//		System.out.println(10/0); / by zero
//		System.out.println(10/0.0);// Infinity
//		System.out.println(0/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(0.0/0);// NaN
		
//		System.out.println(10<Float.NaN);// false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN == Float.NaN);// false
//		System.out.println(10 != Float.NaN);// true
//		System.out.println(Float.NaN != Float.NaN);// true
		
		// need to study further on NaN 
		
		
		
//		2. String Concatenation operator:(+) lecture 18
		
//		String a = "Fahad";
//		int b=10,c=20,d=30;
//		System.out.println(a+b+c+d);// Fahad102030
//		System.out.println(b+c+d+a);// 60Fahad
//		System.out.println(b+c+a+d);// 30Fahad30
//		System.out.println(b+a+c+d);// 10Fahad2030
		
//		System.out.println(a=a+b+c);//Fahad1020
//		System.out.println(a=b+c+d);// Type mismatch: cannot convert from int to String
//		System.out.println(b=a+c+d);// Type mismatch: cannot convert from String to int
//		System.out.println(b=b+c+d);// 60
		
//		4. relational Operator (<,<=,>,>=)
//		System.out.println(10<20);// true
//		System.out.println('a'<20);//false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'<'A');// false
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		System.out.println("fahad102">"fahad");//The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5. Equality operator (==, !=)
		
		
	
		
		
//		--------Revision Practice -----------------------------------------------------------------------------
		
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
//		
//		int x= 10;
//		int y = ++x;
//		System.out.println(y);
//		int z = x++;
//		System.out.println(z);
//		int m = x++;
//		System.out.println(m);
		
		
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
//		
//		int x= 30;
//		int y= x++;
//		int z= ++x;
//		System.out.println(y); // 30
//		System.out.println(x); // 32
		
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
//		int x= 90;
//		int y= x++;
//		System.out.println(x);// 91
//		int y= ++x; //91
//		System.out.println(y);// 90
		
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
		
//		int x= 10;
//		int y= --x;
//		int z = x--;
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
		
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
//		int x= 10;
//		int y= 10++:
//		System.out.println(y);
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
		
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
		
//		int x= 10;
//  	int y= ++(x);
//		int z= ++(++x); // neasting of increment and decrement operators is not allowed.
//		System.out.println(z);
//		++x means value not a variable.. here we required variable not a valuex.
		
		
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		
//		final int x= 10;
//		int y = x++;
//		System.out.println(y);
		
		//The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
//		final int x= 10;
//		x=11;
//		System.out.println(x);
		
		
		
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
		
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
		
		
		
		
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // first assigned then increment.
//		
//		final int x= 10;
//		int y= x++;
//		System.out.println(y);
		
		
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
		
//		char ch = 'a';// a=97
//		ch++;
//		int y=ch;
//		System.out.println(ch);// b  becz value of a is 97 so after increment value becomes 98 which is value of b
//		System.out.println(y);// 98
		
//		double d= 10.9;
//		d++;
//		System.out.println(d);// 11.9
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
		
//		boolean b = false;
//		b++;// b+1-- (false+1)  Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		boolean b = false;
//		System.out.println(b);
		
		
		
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for every primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
		
//		If we applied any arithemetic operators between two variable a and b then
		//the result type is always	max of (int,type of a, type of b)
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+ b;// Type mismatch: cannot convert from int to byte
//		byte c= (byte) (a+b);
//		System.out.println(c);// 30
		
		
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
		
//		byte b =10;
//		b= b+1;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b=(byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11

//		byte b = 10;
//		b++;// internal typecasting happen by default
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr operator internal TypeCasting perform automatically
//		
//		byte b = 10;
//		byte c = 20;
//		byte d =(byte) (b+c);
//		System.out.println(d);// 30
		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->		float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97+0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(10/0);/ by zero
	
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two constatnt.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		System.out.println(10/0.0);
//		System.out.println(10.0/0.0);
//		System.out.println(10/-0.0);
//		System.out.println(-10/0.0);
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// / by zero
		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		System.out.println(10<Float.NaN);// false
		
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it is said arithmetic addition operators 
//		and sometime it is said string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
		
//		String a = "fahad";
//		int b=10,c=20,d=10;
//		System.out.println(a+b+c+d);//
//		System.out.println(b+c+d+a);
//		System.out.println(b+c+a+d);
//		System.out.println(b+a+c+d);
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		String a= "fahad";
//		int b=10, c=20, d=30;
////		a=b+c+d;
////		System.out.println(a);//Type mismatch: cannot convert from int to String
//		a=a+b+c;
////		System.out.println(a);
////		b=a+c+d;
//		b=b+c+d;
//		System.out.println(b);//60
		
		
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for every primitive type except boolean.
//		eg:-
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
//		
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'>'A');// true
//		System.out.println(true<false);
		
//		System.out.println(10<=10);// true
//		System.out.println(10>=10);// true
		
		
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println("fahad">"fahad");
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		System.out.println(10<20>30);// The operator > is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type including boolean also.
		
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
//		System.out.println(10==10);
//		System.out.println(10==20);
//		System.out.println('a'==97.0);
//		System.out.println('a'==97);
//		System.out.println('a'=='a');
//		System.out.println(false==false);// true
//		System.out.println('a'=='A');// false
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3 = t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);
//		System.out.println(O==S);
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
		
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1!=O);// true
//		System.out.println(O!=S);// true
//		System.out.println(S!=t1);// Incompatible operand types String and Thread
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		String S1 = new String("fahad");
//		String S2 = new String("fahad");
//		System.out.println(S1==S2);// false - address compare ho raha
//		System.out.println(S1.equals(S2)); // content/value compare ho rahi
//		
		
		
//		for any object reference r == null is always false
//		but null == null is always true
		
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		
//		String s = new String("durga");
//		System.out.println(s==null);// flase-- address compare and not matched so result is false.
		
//		String n = null;
//		System.out.println(n==null);// true.
//		System.out.println(null==null);// true
		
		
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to check whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);
//		System.out.println(t instanceof Object);
//		System.out.println(t instanceof Runnable);
		
//		int[] l = new int[9];
//		System.out.println(l[0]);
//		Object o = new l.get[0];
		
	
//		 ArrayList<String> l = new ArrayList<String>(); 
//		// Create an ArrayList object
//		 Object O = new l.get[0];
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		Thread t = new Thread();
//		System.out.println(t instanceof String);// Incompatible conditional operand types Thread and String
		
//		System.out.println(null instanceof Thread);// false
//		System.out.println(null instanceof Object);// false
//		System.out.println(null instanceof Runnable);// false
		
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		System.out.println(true & false); // false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false);// true
//		System.out.println(true ^ true);// false	
//		System.out.println(false ^ false);// false
		
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
//		System.out.println( 4 & 5);
//		System.out.println(4 |5);
//		System.out.println(4 ^ 5);
		
//		System.out.println(100 & 101);// 100
//		System.out.println(11 & 11); // 11
		
//		System.out.println(~4);// -5
		
//		System.out.println(~5);// -6
		
//		System.out.println(~38); // -39
		
		
		 
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		System.out.println(!10);
//		System.out.println(!true);
//		System.out.println(!false);
		
		
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
		
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
//		int x = 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		int x = 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16

//		int x = 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 & (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 | (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 | (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 || (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is responsible to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
//		int x= 'a';
//		System.out.println(x);// 97
//		
//		double d = 10;
//		System.out.println(d);// 10.0
		
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		float f = 10;
//		System.out.println(f);// 10.0
		
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		double d = 'a';
//		System.out.println(d);// 97.0
		
//		long l = 'a';
//		System.out.println(l);// 97
		
//		float f = 'a';
//		System.out.println(f);// 97.0
		
		
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		int x = 130;
//		byte b = (byte) x; //  cannot convert from int to byte
//		System.out.println(b);// -126
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
//		
//		int x = 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		int x = 150;
//		byte b= (byte)x;
//		System.out.println(b);// -106
		
//		int x = 509;
//		byte b = (byte)x;
//		System.out.println(b);// -3
		
//		int x = 509;
//		short s = (short)x;
//		System.out.println(s);// 509
		
		
		
		
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
		
//		double d = 130.456;
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		float f = 130.456f;
//		int x = (int)f;
//		System.out.println(x);// 130
		
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
//		int x = 10;
//		literal value 10 assigned to  var x
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
		
//		int a,b,c,d;
//		a=b=c=d=10;
//		System.out.println(a+".."+b+".."+c+".."+d);//10..10..10..10

//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);//20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator then we called that operator is CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		int a = 20;
//		a+=30;// -- a=a+30;
//		System.out.println(a);// 50

//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		byte b =10;
//		b=b+1;// cannot convert from int to byte
//		System.out.println(b);
//		
		
//		byte b = 10;
//		b++;
//		System.out.println(b);// 11

//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b =10;
//		b+=1; // b=b+1 
//		System.out.println(b);// 11

//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b =127;
//		b+=1;
//		System.out.println(b);// -128
		
//		byte b = 127;
//		b+=127;
//		System.out.println(b);//-2
		
//		byte b =127;
//		b+=129;
//		System.out.println(b);//0
		
//		byte b =127;
//		b+=130;
//		System.out.println(b);//1

//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		int a,c;
//		int b=20;
//		int d;
//		a=c=d=20;//chained
//		a+= 10;
//		b-=5;
//		c*=4;
//		d/=7;
//		System.out.println(a+"..."+b+"..."+c+"..."+d);//30...15...80...2
		
//		int a=10;
//		a+=a+10;
//		System.out.println(a);//30
		
//		int a=10;
//		a+=a+=a+=a-+a-+30;
//		System.out.println(a);
		
//		int a=10;
//		a+=12+12;
//		System.out.println(a);//34

//		int a,b,c,d,e,f,g,h;
//		a=b=c=d=e=f=g=h=10;
//		a+=10;
//		b-=10;
//		c/=10;// return quotient
//		d*=10;
//		e%=10; // return reminder
//		
//		f&=10; // f&10==> 10&10 = Ans 10 - 1010&1010==1010=10
//		g|=10; // 
//		h^=10;// x-OR cap 
//		
//		System.out.println(a); // 20
//		System.out.println(b); // 0
//		System.out.println(c); // 1
//		System.out.println(d); // 100
//		System.out.println(e); /// 0
//		System.out.println(f); // 10
//		System.out.println(g);// 10
//		System.out.println(h); // 0
		
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
		
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
		
		int x (10<20)
		
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
//	    1+2*3/4+5*6*7/8+9-10
		
//		If multiple operator has same precedence then it execute from left to right
//		and right to left accrdng to associativity.
		
//		For more detail : See Java operator precedence table
		
//		Lecture 23 : 
//		16.new vs newInstance()
//		1.new : - We can use this new operator to create an object , if we know classname at the beggining
//		eg:- 
//		Test t = new Test();
//		Student S = new Student();
//		Customer C = new Customer();
		
//		2. newInstance():- is a method in Class.class we can use newInstance method to create ibject, if we don't
//		 know class name at begginig and it is available sdynamically at runtime from
//		CLA,file,database.
//		eg: above
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError
//		both above 17 & 18 point are theory based and interview question only 
		
		
		
		


	}
//	public static int m1(int i) {
//	System.out.println(i);// 1,2,3,4,5,6
//	System.out.println(i);//1,2,3,4,5,6.7,8,9,10
//	return i;
//}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-01-01 01:12:39.947
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-01-01 01:12:39.949
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-01-01 01:12:41.146
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList; 
	
public class OperatorsAndAssingments_Practice {
	//class Customer{
//	
//}
//class Test{
//	public static void main(String[] args)throws Exception {
//		Object O = Class.forName(args[0]).newInstance();
//		System.out.println("Object created for :"+O.getClass().getName());
////		System.out.println("Hello");
//- Other rest thing are thoery based and need setting for runnig in run time nad compile time seperately
//	}
//}
	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		Pre Increment
//		int x= 10;
//		int y= ++x;// pre incr -- here y value = 11
//		System.out.println(x);// 11
//		System.out.println(y);// 11
		
//		Post Increment
//		int x= 10;
//		int y= x++;
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		
//		int x= 10;
//		int y= x+1;
//		System.out.println(x);// 10
//		System.out.println(y);// 11
		
//		Pre Decrement
//		int x= 10;
//		int y= --x;
//		System.out.println(y);// 9
//		System.out.println(x);// 9
		
//		Post Decrement
//		int x= 10;
//		int y= x--;
//		System.out.println(y);// 10
//		System.out.println(x);// 9
		
//		int x= 10;
//		int y= ++10;// Invalid argument to operation ++/--
//		System.out.println(x);
////		System.out.println(y);
//		int z = 10++;// Invalid argument to operation ++/--
//		System.out.println(z);
		
		
//		int x= 10;
//		int y= ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		final int x = 10;
//		x++;// The final local variable x cannot be assigned. 
////		It must be blank and not using a compound assignment
//		System.out.println(x);
		
		
//		final int x = 10;
//		x++;
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
		
//		int x = 10;
//		x++;
//		System.out.println(x);
		
//		int x= 10;
//		int y= x++;
//		int z = x;
//		z++;
//		
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		System.out.println(z);// 12
		
//		int x = 10;
//		int y = ++x;
//		int z= y;
//		System.out.println(z);// 11
//		z++;
//		System.out.println(y);// 11
//		System.out.println(x);// 11
//		System.out.println(z);// 12
	
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		double d = 10.5;
//		++d;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;// Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		char ch = 'a';
//		char y = ch++;
//		System.out.println(ch);//b
//		System.out.println(y);//a
		
		
		
		
		
//		Diff Btwen b++ and b=b+1
		
//		byte b = 10;
//		byte a= 10;
//		byte c= a+b;// max(int,type of a, type of b)--> max(int,byte,byte)
//		System.out.println(c);//Type mismatch: cannot convert from int to byte
		
//		byte a = 10;
//		byte b = -1;
//		byte c= (byte)(a+b);
//		System.out.println(c);//9
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = a+b;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		int b = 10;
//		int a= 10;
//		int c = a+b; // max(int,type of a, type of b)--> max(int,int,int)
//		System.out.println(c);// 20
		
//		short a = 10;
//		short b = 10;
//		short c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to short
		
//		short a = 10;
//		short b = 10;
//		short c = (short)(a+b);
//		System.out.println(c);// 20
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = ch + ch1;
//		System.out.println(chs);// Type mismatch: cannot convert from int to char
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = (char)(ch + ch1);
//		System.out.println(chs);//
		
//		char ch2 = '';
//		int in = ch2+0;
//		System.out.println(in);
		
		
//		char ch = 'a';
//		char ch1 = 'b';
//		int x = ch;
//		int y= ch1;
//		System.out.println(x);//97
//		System.out.println(y);//98
		
//		char x = 'a';
//		char y= 'b';
//		long l = x+y;
//		System.out.println(l);// 197
		
//		char x= 'a';
//		char y='b';
//		float f= x+y;
//		System.out.println(f);// 195.0
		
//		char x= 'a';
//		char y='b';
//		double d= x+y;
//		System.out.println(d);// 195.0
		
//		char ch = 'a';
//		double d = 10.5d;
//		double sum = ch +d;
//		System.out.println(sum);// 107.5
		
//		char ch = 'a';
//		double d = 10.5d;
//		int sum = (int)(ch +d);
//		System.out.println(sum);// 107
		
		
		
		
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = (byte)(a+b);// Type mismatch: cannot convert from int to byte
//		System.out.println(c);// 20
		
//		byte b= 10;
//		byte a = 20;
//		byte c = a + b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		byte b= 10;
//		byte a = 20;
//		byte c = (byte)(a + b);
//		System.out.println(c);
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b= (byte)(b+1+b);
//		System.out.println(b);// 21
		
//		byte b = 10;
//		b= (byte)(b+1+b-b+10-12);
//		System.out.println(b);// 9
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b =20;
//		b= b+1;
//		System.out.println(b);
		
//		byte c = 20;
//		c= c++;
//		System.out.println(c);//20
		
		
//		int a = 10;
//		int c = 10;
//		byte z = (byte)(a+c);
//		System.out.println(z);
		
		
		
//		int x= 10;
//		int y = ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		int x= 10;
//		int y= ++ (++x);
//		System.out.println(y);// Invalid argument to operation ++/--
		
		
		
		
		
//		byte c = 20;
//		byte z = c++;
//		System.out.println(z);//20
		
//		byte b = 10;
//		b++;// (byte)b+1
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11
		
		
		
		
//		2. Arithematic Operator - (+,-,*,/,%)
		
//		byte b = 10;
//		byte c = 19;
//		byte sum = (byte)(b+c) ;
//		System.out.println(sum);// 29
		
		
//		byte b = 10;
//		short s = 19;
//		short sum = (short)(b+s);
//		System.out.println(sum);// 29
		
//		short s1 = 10;
//		short s2= 18;
//		short sum = (short)(s1+s2);
//		System.out.println(sum);// 28
		
//		byte b = 10;
//		long l = 19;
//		long sum = b+l;
//		System.out.println(sum);// 29  -- int to long conversion is possible 
		
//		long l = 10;
//		double d = 10.4;
//		double sum = l+d;
//		System.out.println(sum);// 20.4 -- int to double is possible and long is max among
		
		
//		float f = 10.4f;
//		long l = 10;
//		long sum = f+l;// Type mismatch: cannot convert from float to long
//		long sum = (long)(f+l);// 20-- ans in long
//		float sum = l+f;// 20.4
//		System.out.println(sum);
		
//		char ch = 'A';
//		char ch1 = 'B';
//		char sum = ch+ch1;// Type mismatch: cannot convert from int to char
//		int sum = ch+ch1;
//		System.out.println(sum);// 131
		
//		char ch = 'A';
//		double d = 10.5;
//		int sum = ch+d;// Type mismatch: cannot convert from double to int
//		char sum1 = ch+d;// Type mismatch: cannot convert from double to char
//		double sum = ch+d;// 75.5
//		System.out.println(sum);

//		System.out.println('a'+'b');//195
//		System.out.println('a'+10.5);// 107.5
//		System.out.println('a'+0.89);// 97.89
		
//		System.out.println(10/0);// java.lang.ArithmeticException: / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(-10/0.0);// -Infinity
		
//		System.out.println(10/0.0f);// Infinity
//		System.out.println(-10/0.0f);// -Infinity
		
//		System.out.println(10/0);// / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(10.0/0);// Infinity
//		System.out.println(-10.0/0);// -Infinity
		
		
		
//		 NaN- Not a Number
		
//		System.out.println(0/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(0/29);//0
		
//		System.out.println(0/0.0f);// NaN
//		System.out.println(-0/0.0f);// NaN
		
//		System.out.println(0/0.0);// NaN
//		System.out.println(-0/0.0);// NaN
	
//		System.out.println(0/0);//java.lang.ArithmeticException: / by zero
		
//		System.out.println(0.0/0);// NaN
//		
//		System.out.println(-0.0/0);// NaN
		
//		Summary
		
//		System.out.println(10/0); / by zero
//		System.out.println(10/0.0);// Infinity
//		System.out.println(0/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(0.0/0);// NaN
		
//		System.out.println(10<Float.NaN);// false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN == Float.NaN);// false
//		System.out.println(10 != Float.NaN);// true
//		System.out.println(Float.NaN != Float.NaN);// true
		
		// need to study further on NaN 
		
		
		
//		2. String Concatenation operator:(+) lecture 18
		
//		String a = "Fahad";
//		int b=10,c=20,d=30;
//		System.out.println(a+b+c+d);// Fahad102030
//		System.out.println(b+c+d+a);// 60Fahad
//		System.out.println(b+c+a+d);// 30Fahad30
//		System.out.println(b+a+c+d);// 10Fahad2030
		
//		System.out.println(a=a+b+c);//Fahad1020
//		System.out.println(a=b+c+d);// Type mismatch: cannot convert from int to String
//		System.out.println(b=a+c+d);// Type mismatch: cannot convert from String to int
//		System.out.println(b=b+c+d);// 60
		
//		4. relational Operator (<,<=,>,>=)
//		System.out.println(10<20);// true
//		System.out.println('a'<20);//false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'<'A');// false
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		System.out.println("fahad102">"fahad");//The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5. Equality operator (==, !=)
		
		
	
		
		
//		--------Revision Practice -----------------------------------------------------------------------------
		
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
//		
//		int x= 10;
//		int y = ++x;
//		System.out.println(y);
//		int z = x++;
//		System.out.println(z);
//		int m = x++;
//		System.out.println(m);
		
		
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
//		
//		int x= 30;
//		int y= x++;
//		int z= ++x;
//		System.out.println(y); // 30
//		System.out.println(x); // 32
		
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
//		int x= 90;
//		int y= x++;
//		System.out.println(x);// 91
//		int y= ++x; //91
//		System.out.println(y);// 90
		
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
		
//		int x= 10;
//		int y= --x;
//		int z = x--;
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
		
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
//		int x= 10;
//		int y= 10++:
//		System.out.println(y);
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
		
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
		
//		int x= 10;
//  	int y= ++(x);
//		int z= ++(++x); // neasting of increment and decrement operators is not allowed.
//		System.out.println(z);
//		++x means value not a variable.. here we required variable not a valuex.
		
		
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		
//		final int x= 10;
//		int y = x++;
//		System.out.println(y);
		
		//The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
//		final int x= 10;
//		x=11;
//		System.out.println(x);
		
		
		
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
		
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
		
		
		
		
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // first assigned then increment.
//		
//		final int x= 10;
//		int y= x++;
//		System.out.println(y);
		
		
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
		
//		char ch = 'a';// a=97
//		ch++;
//		int y=ch;
//		System.out.println(ch);// b  becz value of a is 97 so after increment value becomes 98 which is value of b
//		System.out.println(y);// 98
		
//		double d= 10.9;
//		d++;
//		System.out.println(d);// 11.9
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
		
//		boolean b = false;
//		b++;// b+1-- (false+1)  Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		boolean b = false;
//		System.out.println(b);
		
		
		
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for every primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
		
//		If we applied any arithemetic operators between two variable a and b then
		//the result type is always	max of (int,type of a, type of b)
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+ b;// Type mismatch: cannot convert from int to byte
//		byte c= (byte) (a+b);
//		System.out.println(c);// 30
		
		
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
		
//		byte b =10;
//		b= b+1;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b=(byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11

//		byte b = 10;
//		b++;// internal typecasting happen by default
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr operator internal TypeCasting perform automatically
//		
//		byte b = 10;
//		byte c = 20;
//		byte d =(byte) (b+c);
//		System.out.println(d);// 30
		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->		float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97+0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(10/0);/ by zero
	
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two constatnt.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		System.out.println(10/0.0);
//		System.out.println(10.0/0.0);
//		System.out.println(10/-0.0);
//		System.out.println(-10/0.0);
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// / by zero
		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		System.out.println(10<Float.NaN);// false
		
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it is said arithmetic addition operators 
//		and sometime it is said string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
		
//		String a = "fahad";
//		int b=10,c=20,d=10;
//		System.out.println(a+b+c+d);//
//		System.out.println(b+c+d+a);
//		System.out.println(b+c+a+d);
//		System.out.println(b+a+c+d);
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		String a= "fahad";
//		int b=10, c=20, d=30;
////		a=b+c+d;
////		System.out.println(a);//Type mismatch: cannot convert from int to String
//		a=a+b+c;
////		System.out.println(a);
////		b=a+c+d;
//		b=b+c+d;
//		System.out.println(b);//60
		
		
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for every primitive type except boolean.
//		eg:-
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
//		
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'>'A');// true
//		System.out.println(true<false);
		
//		System.out.println(10<=10);// true
//		System.out.println(10>=10);// true
		
		
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println("fahad">"fahad");
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		System.out.println(10<20>30);// The operator > is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type including boolean also.
		
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
//		System.out.println(10==10);
//		System.out.println(10==20);
//		System.out.println('a'==97.0);
//		System.out.println('a'==97);
//		System.out.println('a'=='a');
//		System.out.println(false==false);// true
//		System.out.println('a'=='A');// false
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3 = t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);
//		System.out.println(O==S);
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
		
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1!=O);// true
//		System.out.println(O!=S);// true
//		System.out.println(S!=t1);// Incompatible operand types String and Thread
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		String S1 = new String("fahad");
//		String S2 = new String("fahad");
//		System.out.println(S1==S2);// false - address compare ho raha
//		System.out.println(S1.equals(S2)); // content/value compare ho rahi
//		
		
		
//		for any object reference r == null is always false
//		but null == null is always true
		
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		
//		String s = new String("durga");
//		System.out.println(s==null);// flase-- address compare and not matched so result is false.
		
//		String n = null;
//		System.out.println(n==null);// true.
//		System.out.println(null==null);// true
		
		
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to check whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);
//		System.out.println(t instanceof Object);
//		System.out.println(t instanceof Runnable);
		
//		int[] l = new int[9];
//		System.out.println(l[0]);
//		Object o = new l.get[0];
		
	
//		 ArrayList<String> l = new ArrayList<String>(); 
//		// Create an ArrayList object
//		 Object O = new l.get[0];
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		Thread t = new Thread();
//		System.out.println(t instanceof String);// Incompatible conditional operand types Thread and String
		
//		System.out.println(null instanceof Thread);// false
//		System.out.println(null instanceof Object);// false
//		System.out.println(null instanceof Runnable);// false
		
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		System.out.println(true & false); // false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false);// true
//		System.out.println(true ^ true);// false	
//		System.out.println(false ^ false);// false
		
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
//		System.out.println( 4 & 5);
//		System.out.println(4 |5);
//		System.out.println(4 ^ 5);
		
//		System.out.println(100 & 101);// 100
//		System.out.println(11 & 11); // 11
		
//		System.out.println(~4);// -5
		
//		System.out.println(~5);// -6
		
//		System.out.println(~38); // -39
		
		
		 
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		System.out.println(!10);
//		System.out.println(!true);
//		System.out.println(!false);
		
		
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
		
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
//		int x = 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		int x = 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16

//		int x = 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 & (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 | (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 | (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 || (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is responsible to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
//		int x= 'a';
//		System.out.println(x);// 97
//		
//		double d = 10;
//		System.out.println(d);// 10.0
		
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		float f = 10;
//		System.out.println(f);// 10.0
		
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		double d = 'a';
//		System.out.println(d);// 97.0
		
//		long l = 'a';
//		System.out.println(l);// 97
		
//		float f = 'a';
//		System.out.println(f);// 97.0
		
		
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		int x = 130;
//		byte b = (byte) x; //  cannot convert from int to byte
//		System.out.println(b);// -126
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
//		
//		int x = 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		int x = 150;
//		byte b= (byte)x;
//		System.out.println(b);// -106
		
//		int x = 509;
//		byte b = (byte)x;
//		System.out.println(b);// -3
		
//		int x = 509;
//		short s = (short)x;
//		System.out.println(s);// 509
		
		
		
		
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
		
//		double d = 130.456;
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		float f = 130.456f;
//		int x = (int)f;
//		System.out.println(x);// 130
		
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
//		int x = 10;
//		literal value 10 assigned to  var x
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
		
//		int a,b,c,d;
//		a=b=c=d=10;
//		System.out.println(a+".."+b+".."+c+".."+d);//10..10..10..10

//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);//20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator then we called that operator is CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		int a = 20;
//		a+=30;// -- a=a+30;
//		System.out.println(a);// 50

//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		byte b =10;
//		b=b+1;// cannot convert from int to byte
//		System.out.println(b);
//		
		
//		byte b = 10;
//		b++;
//		System.out.println(b);// 11

//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b =10;
//		b+=1; // b=b+1 
//		System.out.println(b);// 11

//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b =127;
//		b+=1;
//		System.out.println(b);// -128
		
//		byte b = 127;
//		b+=127;
//		System.out.println(b);//-2
		
//		byte b =127;
//		b+=129;
//		System.out.println(b);//0
		
//		byte b =127;
//		b+=130;
//		System.out.println(b);//1

//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		int a,c;
//		int b=20;
//		int d;
//		a=c=d=20;//chained
//		a+= 10;
//		b-=5;
//		c*=4;
//		d/=7;
//		System.out.println(a+"..."+b+"..."+c+"..."+d);//30...15...80...2
		
//		int a=10;
//		a+=a+10;
//		System.out.println(a);//30
		
//		int a=10;
//		a+=a+=a+=a-+a-+30;
//		System.out.println(a);
		
//		int a=10;
//		a+=12+12;
//		System.out.println(a);//34

//		int a,b,c,d,e,f,g,h;
//		a=b=c=d=e=f=g=h=10;
//		a+=10;
//		b-=10;
//		c/=10;// return quotient
//		d*=10;
//		e%=10; // return reminder
//		
//		f&=10; // f&10==> 10&10 = Ans 10 - 1010&1010==1010=10
//		g|=10; // 
//		h^=10;// x-OR cap 
//		
//		System.out.println(a); // 20
//		System.out.println(b); // 0
//		System.out.println(c); // 1
//		System.out.println(d); // 100
//		System.out.println(e); /// 0
//		System.out.println(f); // 10
//		System.out.println(g);// 10
//		System.out.println(h); // 0
		
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
		
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
		
		int x (10<20)
		
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
//	    1+2*3/4+5*6*7/8+9-10
		
//		If multiple operator has same precedence then it execute from left to right
//		and right to left accrdng to associativity.
		
//		For more detail : See Java operator precedence table
		
//		Lecture 23 : 
//		16.new vs newInstance()
//		1.new : - We can use this new operator to create an object , if we know classname at the beggining
//		eg:- 
//		Test t = new Test();
//		Student S = new Student();
//		Customer C = new Customer();
		
//		2. newInstance():- is a method in Class.class we can use newInstance method to create ibject, if we don't
//		 know class name at begginig and it is available sdynamically at runtime from
//		CLA,file,database.
//		eg: above
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError
//		both above 17 & 18 point are theory based and interview question only 
		
		
		
		


	}
//	public static int m1(int i) {
//	System.out.println(i);// 1,2,3,4,5,6
//	System.out.println(i);//1,2,3,4,5,6.7,8,9,10
//	return i;
//}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-01-01 01:12:41.149
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-01-01 01:12:41.151
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core 4 4 2024-01-01 01:12:47.193
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList; 
	
public class OperatorsAndAssingments_Practice {
	//class Customer{
//	
//}
//class Test{
//	public static void main(String[] args)throws Exception {
//		Object O = Class.forName(args[0]).newInstance();
//		System.out.println("Object created for :"+O.getClass().getName());
////		System.out.println("Hello");
//- Other rest thing are thoery based and need setting for runnig in run time nad compile time seperately
//	}
//}
	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		Pre Increment
//		int x= 10;
//		int y= ++x;// pre incr -- here y value = 11
//		System.out.println(x);// 11
//		System.out.println(y);// 11
		
//		Post Increment
//		int x= 10;
//		int y= x++;
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		
//		int x= 10;
//		int y= x+1;
//		System.out.println(x);// 10
//		System.out.println(y);// 11
		
//		Pre Decrement
//		int x= 10;
//		int y= --x;
//		System.out.println(y);// 9
//		System.out.println(x);// 9
		
//		Post Decrement
//		int x= 10;
//		int y= x--;
//		System.out.println(y);// 10
//		System.out.println(x);// 9
		
//		int x= 10;
//		int y= ++10;// Invalid argument to operation ++/--
//		System.out.println(x);
////		System.out.println(y);
//		int z = 10++;// Invalid argument to operation ++/--
//		System.out.println(z);
		
		
//		int x= 10;
//		int y= ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		final int x = 10;
//		x++;// The final local variable x cannot be assigned. 
////		It must be blank and not using a compound assignment
//		System.out.println(x);
		
		
//		final int x = 10;
//		x++;
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
		
//		int x = 10;
//		x++;
//		System.out.println(x);
		
//		int x= 10;
//		int y= x++;
//		int z = x;
//		z++;
//		
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		System.out.println(z);// 12
		
//		int x = 10;
//		int y = ++x;
//		int z= y;
//		System.out.println(z);// 11
//		z++;
//		System.out.println(y);// 11
//		System.out.println(x);// 11
//		System.out.println(z);// 12
	
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		double d = 10.5;
//		++d;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;// Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		char ch = 'a';
//		char y = ch++;
//		System.out.println(ch);//b
//		System.out.println(y);//a
		
		
		
		
		
//		Diff Btwen b++ and b=b+1
		
//		byte b = 10;
//		byte a= 10;
//		byte c= a+b;// max(int,type of a, type of b)--> max(int,byte,byte)
//		System.out.println(c);//Type mismatch: cannot convert from int to byte
		
//		byte a = 10;
//		byte b = -1;
//		byte c= (byte)(a+b);
//		System.out.println(c);//9
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = a+b;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		int b = 10;
//		int a= 10;
//		int c = a+b; // max(int,type of a, type of b)--> max(int,int,int)
//		System.out.println(c);// 20
		
//		short a = 10;
//		short b = 10;
//		short c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to short
		
//		short a = 10;
//		short b = 10;
//		short c = (short)(a+b);
//		System.out.println(c);// 20
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = ch + ch1;
//		System.out.println(chs);// Type mismatch: cannot convert from int to char
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = (char)(ch + ch1);
//		System.out.println(chs);//
		
//		char ch2 = '';
//		int in = ch2+0;
//		System.out.println(in);
		
		
//		char ch = 'a';
//		char ch1 = 'b';
//		int x = ch;
//		int y= ch1;
//		System.out.println(x);//97
//		System.out.println(y);//98
		
//		char x = 'a';
//		char y= 'b';
//		long l = x+y;
//		System.out.println(l);// 197
		
//		char x= 'a';
//		char y='b';
//		float f= x+y;
//		System.out.println(f);// 195.0
		
//		char x= 'a';
//		char y='b';
//		double d= x+y;
//		System.out.println(d);// 195.0
		
//		char ch = 'a';
//		double d = 10.5d;
//		double sum = ch +d;
//		System.out.println(sum);// 107.5
		
//		char ch = 'a';
//		double d = 10.5d;
//		int sum = (int)(ch +d);
//		System.out.println(sum);// 107
		
		
		
		
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = (byte)(a+b);// Type mismatch: cannot convert from int to byte
//		System.out.println(c);// 20
		
//		byte b= 10;
//		byte a = 20;
//		byte c = a + b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		byte b= 10;
//		byte a = 20;
//		byte c = (byte)(a + b);
//		System.out.println(c);
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b= (byte)(b+1+b);
//		System.out.println(b);// 21
		
//		byte b = 10;
//		b= (byte)(b+1+b-b+10-12);
//		System.out.println(b);// 9
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b =20;
//		b= b+1;
//		System.out.println(b);
		
//		byte c = 20;
//		c= c++;
//		System.out.println(c);//20
		
		
//		int a = 10;
//		int c = 10;
//		byte z = (byte)(a+c);
//		System.out.println(z);
		
		
		
//		int x= 10;
//		int y = ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		int x= 10;
//		int y= ++ (++x);
//		System.out.println(y);// Invalid argument to operation ++/--
		
		
		
		
		
//		byte c = 20;
//		byte z = c++;
//		System.out.println(z);//20
		
//		byte b = 10;
//		b++;// (byte)b+1
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11
		
		
		
		
//		2. Arithematic Operator - (+,-,*,/,%)
		
//		byte b = 10;
//		byte c = 19;
//		byte sum = (byte)(b+c) ;
//		System.out.println(sum);// 29
		
		
//		byte b = 10;
//		short s = 19;
//		short sum = (short)(b+s);
//		System.out.println(sum);// 29
		
//		short s1 = 10;
//		short s2= 18;
//		short sum = (short)(s1+s2);
//		System.out.println(sum);// 28
		
//		byte b = 10;
//		long l = 19;
//		long sum = b+l;
//		System.out.println(sum);// 29  -- int to long conversion is possible 
		
//		long l = 10;
//		double d = 10.4;
//		double sum = l+d;
//		System.out.println(sum);// 20.4 -- int to double is possible and long is max among
		
		
//		float f = 10.4f;
//		long l = 10;
//		long sum = f+l;// Type mismatch: cannot convert from float to long
//		long sum = (long)(f+l);// 20-- ans in long
//		float sum = l+f;// 20.4
//		System.out.println(sum);
		
//		char ch = 'A';
//		char ch1 = 'B';
//		char sum = ch+ch1;// Type mismatch: cannot convert from int to char
//		int sum = ch+ch1;
//		System.out.println(sum);// 131
		
//		char ch = 'A';
//		double d = 10.5;
//		int sum = ch+d;// Type mismatch: cannot convert from double to int
//		char sum1 = ch+d;// Type mismatch: cannot convert from double to char
//		double sum = ch+d;// 75.5
//		System.out.println(sum);

//		System.out.println('a'+'b');//195
//		System.out.println('a'+10.5);// 107.5
//		System.out.println('a'+0.89);// 97.89
		
//		System.out.println(10/0);// java.lang.ArithmeticException: / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(-10/0.0);// -Infinity
		
//		System.out.println(10/0.0f);// Infinity
//		System.out.println(-10/0.0f);// -Infinity
		
//		System.out.println(10/0);// / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(10.0/0);// Infinity
//		System.out.println(-10.0/0);// -Infinity
		
		
		
//		 NaN- Not a Number
		
//		System.out.println(0/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(0/29);//0
		
//		System.out.println(0/0.0f);// NaN
//		System.out.println(-0/0.0f);// NaN
		
//		System.out.println(0/0.0);// NaN
//		System.out.println(-0/0.0);// NaN
	
//		System.out.println(0/0);//java.lang.ArithmeticException: / by zero
		
//		System.out.println(0.0/0);// NaN
//		
//		System.out.println(-0.0/0);// NaN
		
//		Summary
		
//		System.out.println(10/0); / by zero
//		System.out.println(10/0.0);// Infinity
//		System.out.println(0/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(0.0/0);// NaN
		
//		System.out.println(10<Float.NaN);// false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN == Float.NaN);// false
//		System.out.println(10 != Float.NaN);// true
//		System.out.println(Float.NaN != Float.NaN);// true
		
		// need to study further on NaN 
		
		
		
//		2. String Concatenation operator:(+) lecture 18
		
//		String a = "Fahad";
//		int b=10,c=20,d=30;
//		System.out.println(a+b+c+d);// Fahad102030
//		System.out.println(b+c+d+a);// 60Fahad
//		System.out.println(b+c+a+d);// 30Fahad30
//		System.out.println(b+a+c+d);// 10Fahad2030
		
//		System.out.println(a=a+b+c);//Fahad1020
//		System.out.println(a=b+c+d);// Type mismatch: cannot convert from int to String
//		System.out.println(b=a+c+d);// Type mismatch: cannot convert from String to int
//		System.out.println(b=b+c+d);// 60
		
//		4. relational Operator (<,<=,>,>=)
//		System.out.println(10<20);// true
//		System.out.println('a'<20);//false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'<'A');// false
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		System.out.println("fahad102">"fahad");//The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5. Equality operator (==, !=)
		
		
	
		
		
//		--------Revision Practice -----------------------------------------------------------------------------
		
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
//		
//		int x= 10;
//		int y = ++x;
//		System.out.println(y);
//		int z = x++;
//		System.out.println(z);
//		int m = x++;
//		System.out.println(m);
		
		
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
//		
//		int x= 30;
//		int y= x++;
//		int z= ++x;
//		System.out.println(y); // 30
//		System.out.println(x); // 32
		
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
//		int x= 90;
//		int y= x++;
//		System.out.println(x);// 91
//		int y= ++x; //91
//		System.out.println(y);// 90
		
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
		
//		int x= 10;
//		int y= --x;
//		int z = x--;
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
		
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
//		int x= 10;
//		int y= 10++:
//		System.out.println(y);
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
		
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
		
//		int x= 10;
//  	int y= ++(x);
//		int z= ++(++x); // neasting of increment and decrement operators is not allowed.
//		System.out.println(z);
//		++x means value not a variable.. here we required variable not a valuex.
		
		
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		
//		final int x= 10;
//		int y = x++;
//		System.out.println(y);
		
		//The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
//		final int x= 10;
//		x=11;
//		System.out.println(x);
		
		
		
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
		
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
		
		
		
		
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // first assigned then increment.
//		
//		final int x= 10;
//		int y= x++;
//		System.out.println(y);
		
		
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
		
//		char ch = 'a';// a=97
//		ch++;
//		int y=ch;
//		System.out.println(ch);// b  becz value of a is 97 so after increment value becomes 98 which is value of b
//		System.out.println(y);// 98
		
//		double d= 10.9;
//		d++;
//		System.out.println(d);// 11.9
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
		
//		boolean b = false;
//		b++;// b+1-- (false+1)  Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		boolean b = false;
//		System.out.println(b);
		
		
		
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for every primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
		
//		If we applied any arithemetic operators between two variable a and b then
		//the result type is always	max of (int,type of a, type of b)
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+ b;// Type mismatch: cannot convert from int to byte
//		byte c= (byte) (a+b);
//		System.out.println(c);// 30
		
		
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
		
//		byte b =10;
//		b= b+1;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b=(byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11

//		byte b = 10;
//		b++;// internal typecasting happen by default
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr operator internal TypeCasting perform automatically
//		
//		byte b = 10;
//		byte c = 20;
//		byte d =(byte) (b+c);
//		System.out.println(d);// 30
		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->		float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97+0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(10/0);/ by zero
	
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two constatnt.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		System.out.println(10/0.0);
//		System.out.println(10.0/0.0);
//		System.out.println(10/-0.0);
//		System.out.println(-10/0.0);
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// / by zero
		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		System.out.println(10<Float.NaN);// false
		
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it is said arithmetic addition operators 
//		and sometime it is said string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
		
//		String a = "fahad";
//		int b=10,c=20,d=10;
//		System.out.println(a+b+c+d);//
//		System.out.println(b+c+d+a);
//		System.out.println(b+c+a+d);
//		System.out.println(b+a+c+d);
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		String a= "fahad";
//		int b=10, c=20, d=30;
////		a=b+c+d;
////		System.out.println(a);//Type mismatch: cannot convert from int to String
//		a=a+b+c;
////		System.out.println(a);
////		b=a+c+d;
//		b=b+c+d;
//		System.out.println(b);//60
		
		
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for every primitive type except boolean.
//		eg:-
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
//		
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'>'A');// true
//		System.out.println(true<false);
		
//		System.out.println(10<=10);// true
//		System.out.println(10>=10);// true
		
		
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println("fahad">"fahad");
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		System.out.println(10<20>30);// The operator > is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type including boolean also.
		
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
//		System.out.println(10==10);
//		System.out.println(10==20);
//		System.out.println('a'==97.0);
//		System.out.println('a'==97);
//		System.out.println('a'=='a');
//		System.out.println(false==false);// true
//		System.out.println('a'=='A');// false
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3 = t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);
//		System.out.println(O==S);
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
		
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1!=O);// true
//		System.out.println(O!=S);// true
//		System.out.println(S!=t1);// Incompatible operand types String and Thread
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		String S1 = new String("fahad");
//		String S2 = new String("fahad");
//		System.out.println(S1==S2);// false - address compare ho raha
//		System.out.println(S1.equals(S2)); // content/value compare ho rahi
//		
		
		
//		for any object reference r == null is always false
//		but null == null is always true
		
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		
//		String s = new String("durga");
//		System.out.println(s==null);// flase-- address compare and not matched so result is false.
		
//		String n = null;
//		System.out.println(n==null);// true.
//		System.out.println(null==null);// true
		
		
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to check whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);
//		System.out.println(t instanceof Object);
//		System.out.println(t instanceof Runnable);
		
//		int[] l = new int[9];
//		System.out.println(l[0]);
//		Object o = new l.get[0];
		
	
//		 ArrayList<String> l = new ArrayList<String>(); 
//		// Create an ArrayList object
//		 Object O = new l.get[0];
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		Thread t = new Thread();
//		System.out.println(t instanceof String);// Incompatible conditional operand types Thread and String
		
//		System.out.println(null instanceof Thread);// false
//		System.out.println(null instanceof Object);// false
//		System.out.println(null instanceof Runnable);// false
		
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		System.out.println(true & false); // false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false);// true
//		System.out.println(true ^ true);// false	
//		System.out.println(false ^ false);// false
		
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
//		System.out.println( 4 & 5);
//		System.out.println(4 |5);
//		System.out.println(4 ^ 5);
		
//		System.out.println(100 & 101);// 100
//		System.out.println(11 & 11); // 11
		
//		System.out.println(~4);// -5
		
//		System.out.println(~5);// -6
		
//		System.out.println(~38); // -39
		
		
		 
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		System.out.println(!10);
//		System.out.println(!true);
//		System.out.println(!false);
		
		
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
		
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
//		int x = 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		int x = 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16

//		int x = 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 & (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 | (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 | (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 || (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is responsible to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
//		int x= 'a';
//		System.out.println(x);// 97
//		
//		double d = 10;
//		System.out.println(d);// 10.0
		
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		float f = 10;
//		System.out.println(f);// 10.0
		
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		double d = 'a';
//		System.out.println(d);// 97.0
		
//		long l = 'a';
//		System.out.println(l);// 97
		
//		float f = 'a';
//		System.out.println(f);// 97.0
		
		
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		int x = 130;
//		byte b = (byte) x; //  cannot convert from int to byte
//		System.out.println(b);// -126
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
//		
//		int x = 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		int x = 150;
//		byte b= (byte)x;
//		System.out.println(b);// -106
		
//		int x = 509;
//		byte b = (byte)x;
//		System.out.println(b);// -3
		
//		int x = 509;
//		short s = (short)x;
//		System.out.println(s);// 509
		
		
		
		
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
		
//		double d = 130.456;
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		float f = 130.456f;
//		int x = (int)f;
//		System.out.println(x);// 130
		
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
//		int x = 10;
//		literal value 10 assigned to  var x
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
		
//		int a,b,c,d;
//		a=b=c=d=10;
//		System.out.println(a+".."+b+".."+c+".."+d);//10..10..10..10

//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);//20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator then we called that operator is CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		int a = 20;
//		a+=30;// -- a=a+30;
//		System.out.println(a);// 50

//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		byte b =10;
//		b=b+1;// cannot convert from int to byte
//		System.out.println(b);
//		
		
//		byte b = 10;
//		b++;
//		System.out.println(b);// 11

//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b =10;
//		b+=1; // b=b+1 
//		System.out.println(b);// 11

//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b =127;
//		b+=1;
//		System.out.println(b);// -128
		
//		byte b = 127;
//		b+=127;
//		System.out.println(b);//-2
		
//		byte b =127;
//		b+=129;
//		System.out.println(b);//0
		
//		byte b =127;
//		b+=130;
//		System.out.println(b);//1

//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		int a,c;
//		int b=20;
//		int d;
//		a=c=d=20;//chained
//		a+= 10;
//		b-=5;
//		c*=4;
//		d/=7;
//		System.out.println(a+"..."+b+"..."+c+"..."+d);//30...15...80...2
		
//		int a=10;
//		a+=a+10;
//		System.out.println(a);//30
		
//		int a=10;
//		a+=a+=a+=a-+a-+30;
//		System.out.println(a);
		
//		int a=10;
//		a+=12+12;
//		System.out.println(a);//34

//		int a,b,c,d,e,f,g,h;
//		a=b=c=d=e=f=g=h=10;
//		a+=10;
//		b-=10;
//		c/=10;// return quotient
//		d*=10;
//		e%=10; // return reminder
//		
//		f&=10; // f&10==> 10&10 = Ans 10 - 1010&1010==1010=10
//		g|=10; // 
//		h^=10;// x-OR cap 
//		
//		System.out.println(a); // 20
//		System.out.println(b); // 0
//		System.out.println(c); // 1
//		System.out.println(d); // 100
//		System.out.println(e); /// 0
//		System.out.println(f); // 10
//		System.out.println(g);// 10
//		System.out.println(h); // 0
		
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
		
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
		
		int x (10<20)
		
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executing to perform
//		initialization of object not for creation of object
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=.args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
//	    1+2*3/4+5*6*7/8+9-10
		
//		If multiple operator has same precedence then it execute from left to right
//		and right to left accrdng to associativity.
		
//		For more detail : See Java operator precedence table
		
//		Lecture 23 : 
//		16.new vs newInstance()
//		1.new : - We can use this new operator to create an object , if we know classname at the beggining
//		eg:- 
//		Test t = new Test();
//		Student S = new Student();
//		Customer C = new Customer();
		
//		2. newInstance():- is a method in Class.class we can use newInstance method to create ibject, if we don't
//		 know class name at begginig and it is available sdynamically at runtime from
//		CLA,file,database.
//		eg: above
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError
//		both above 17 & 18 point are theory based and interview question only 
		
		
		
		


	}
//	public static int m1(int i) {
//	System.out.println(i);// 1,2,3,4,5,6
//	System.out.println(i);//1,2,3,4,5,6.7,8,9,10
//	return i;
//}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-01-01 01:12:47.196
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-01-01 01:12:47.198
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
!SESSION 2024-01-01 23:00:36.466 -----------------------------------------------
eclipse.buildId=4.22.0.I20211124-1800
java.version=17.0.6
java.vendor=Oracle Corporation
BootLoader constants: OS=win32, ARCH=x86_64, WS=win32, NL=en_US
Framework arguments:  -product org.eclipse.epp.package.java.product
Command-line arguments:  -os win32 -ws win32 -arch x86_64 -product org.eclipse.epp.package.java.product

!ENTRY org.eclipse.jface 2 0 2024-01-01 23:00:47.319
!MESSAGE Keybinding conflicts occurred.  They may interfere with normal accelerator operation.
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-01 23:00:47.319
!MESSAGE A conflict occurred for CTRL+SHIFT+T:
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.navigate.open.type,Open Type,
		Open a type in a Java editor,
		Category(org.eclipse.ui.category.navigate,Navigate,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@20231384,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(CTRL+SHIFT+T,
	ParameterizedCommand(Command(org.eclipse.lsp4e.symbolinworkspace,Go to Symbol in Workspace,
		,
		Category(org.eclipse.lsp4e.category,Language Servers,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3ba97962,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
!SUBENTRY 1 org.eclipse.jface 2 0 2024-01-01 23:00:47.319
!MESSAGE A conflict occurred for ALT+SHIFT+R:
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.jdt.ui.edit.text.java.rename.element,Rename - Refactoring ,
		Rename the selected element,
		Category(org.eclipse.jdt.ui.category.refactoring,Refactor - Java,Java Refactoring Actions,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@35becbd4,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)
Binding(ALT+SHIFT+R,
	ParameterizedCommand(Command(org.eclipse.ui.edit.rename,Rename,
		Rename the selected item,
		Category(org.eclipse.ui.category.file,File,null,true),
		org.eclipse.ui.internal.WorkbenchHandlerServiceHandler@3bcc8f13,
		,,true),null),
	org.eclipse.ui.defaultAcceleratorConfiguration,
	org.eclipse.ui.contexts.window,,,system)

!ENTRY org.eclipse.egit.ui 2 0 2024-01-01 23:00:57.749
!MESSAGE Warning: The environment variable HOME is not set. The following directory will be used to store the Git
user global configuration and to define the default location to store repositories: 'C:\Users\2101917'. If this is
not correct please set the HOME environment variable and restart Eclipse. Otherwise Git for Windows and
EGit might behave differently since they see different configuration options.
This warning can be switched off on the Team > Git > Confirmations and Warnings preference page.

!ENTRY org.eclipse.jdt.core 4 4 2024-01-01 23:28:33.314
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList; 
	
public class OperatorsAndAssingments_Practice {
	//class Customer{
//	
//}
//class Test{
//	public static void main(String[] args)throws Exception {
//		Object O = Class.forName(args[0]).newInstance();
//		System.out.println("Object created for :"+O.getClass().getName());
////		System.out.println("Hello");
//- Other rest thing are thoery based and need setting for runnig in run time nad compile time seperately
//	}
//}
	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		Pre Increment
//		int x= 10;
//		int y= ++x;// pre incr -- here y value = 11
//		System.out.println(x);// 11
//		System.out.println(y);// 11
		
//		Post Increment
//		int x= 10;
//		int y= x++;
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		
//		int x= 10;
//		int y= x+1;
//		System.out.println(x);// 10
//		System.out.println(y);// 11
		
//		Pre Decrement
//		int x= 10;
//		int y= --x;
//		System.out.println(y);// 9
//		System.out.println(x);// 9
		
//		Post Decrement
//		int x= 10;
//		int y= x--;
//		System.out.println(y);// 10
//		System.out.println(x);// 9
		
//		int x= 10;
//		int y= ++10;// Invalid argument to operation ++/--
//		System.out.println(x);
////		System.out.println(y);
//		int z = 10++;// Invalid argument to operation ++/--
//		System.out.println(z);
		
		
//		int x= 10;
//		int y= ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		final int x = 10;
//		x++;// The final local variable x cannot be assigned. 
////		It must be blank and not using a compound assignment
//		System.out.println(x);
		
		
//		final int x = 10;
//		x++;
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
		
//		int x = 10;
//		x++;
//		System.out.println(x);
		
//		int x= 10;
//		int y= x++;
//		int z = x;
//		z++;
//		
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		System.out.println(z);// 12
		
//		int x = 10;
//		int y = ++x;
//		int z= y;
//		System.out.println(z);// 11
//		z++;
//		System.out.println(y);// 11
//		System.out.println(x);// 11
//		System.out.println(z);// 12
	
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		double d = 10.5;
//		++d;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;// Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		char ch = 'a';
//		char y = ch++;
//		System.out.println(ch);//b
//		System.out.println(y);//a
		
		
		
		
		
//		Diff Btwen b++ and b=b+1
		
//		byte b = 10;
//		byte a= 10;
//		byte c= a+b;// max(int,type of a, type of b)--> max(int,byte,byte)
//		System.out.println(c);//Type mismatch: cannot convert from int to byte
		
//		byte a = 10;
//		byte b = -1;
//		byte c= (byte)(a+b);
//		System.out.println(c);//9
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = a+b;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		int b = 10;
//		int a= 10;
//		int c = a+b; // max(int,type of a, type of b)--> max(int,int,int)
//		System.out.println(c);// 20
		
//		short a = 10;
//		short b = 10;
//		short c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to short
		
//		short a = 10;
//		short b = 10;
//		short c = (short)(a+b);
//		System.out.println(c);// 20
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = ch + ch1;
//		System.out.println(chs);// Type mismatch: cannot convert from int to char
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = (char)(ch + ch1);
//		System.out.println(chs);//
		
//		char ch2 = '';
//		int in = ch2+0;
//		System.out.println(in);
		
		
//		char ch = 'a';
//		char ch1 = 'b';
//		int x = ch;
//		int y= ch1;
//		System.out.println(x);//97
//		System.out.println(y);//98
		
//		char x = 'a';
//		char y= 'b';
//		long l = x+y;
//		System.out.println(l);// 197
		
//		char x= 'a';
//		char y='b';
//		float f= x+y;
//		System.out.println(f);// 195.0
		
//		char x= 'a';
//		char y='b';
//		double d= x+y;
//		System.out.println(d);// 195.0
		
//		char ch = 'a';
//		double d = 10.5d;
//		double sum = ch +d;
//		System.out.println(sum);// 107.5
		
//		char ch = 'a';
//		double d = 10.5d;
//		int sum = (int)(ch +d);
//		System.out.println(sum);// 107
		
		
		
		
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = (byte)(a+b);// Type mismatch: cannot convert from int to byte
//		System.out.println(c);// 20
		
//		byte b= 10;
//		byte a = 20;
//		byte c = a + b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		byte b= 10;
//		byte a = 20;
//		byte c = (byte)(a + b);
//		System.out.println(c);
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b= (byte)(b+1+b);
//		System.out.println(b);// 21
		
//		byte b = 10;
//		b= (byte)(b+1+b-b+10-12);
//		System.out.println(b);// 9
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b =20;
//		b= b+1;
//		System.out.println(b);
		
//		byte c = 20;
//		c= c++;
//		System.out.println(c);//20
		
		
//		int a = 10;
//		int c = 10;
//		byte z = (byte)(a+c);
//		System.out.println(z);
		
		
		
//		int x= 10;
//		int y = ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		int x= 10;
//		int y= ++ (++x);
//		System.out.println(y);// Invalid argument to operation ++/--
		
		
		
		
		
//		byte c = 20;
//		byte z = c++;
//		System.out.println(z);//20
		
//		byte b = 10;
//		b++;// (byte)b+1
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11
		
		
		
		
//		2. Arithematic Operator - (+,-,*,/,%)
		
//		byte b = 10;
//		byte c = 19;
//		byte sum = (byte)(b+c) ;
//		System.out.println(sum);// 29
		
		
//		byte b = 10;
//		short s = 19;
//		short sum = (short)(b+s);
//		System.out.println(sum);// 29
		
//		short s1 = 10;
//		short s2= 18;
//		short sum = (short)(s1+s2);
//		System.out.println(sum);// 28
		
//		byte b = 10;
//		long l = 19;
//		long sum = b+l;
//		System.out.println(sum);// 29  -- int to long conversion is possible 
		
//		long l = 10;
//		double d = 10.4;
//		double sum = l+d;
//		System.out.println(sum);// 20.4 -- int to double is possible and long is max among
		
		
//		float f = 10.4f;
//		long l = 10;
//		long sum = f+l;// Type mismatch: cannot convert from float to long
//		long sum = (long)(f+l);// 20-- ans in long
//		float sum = l+f;// 20.4
//		System.out.println(sum);
		
//		char ch = 'A';
//		char ch1 = 'B';
//		char sum = ch+ch1;// Type mismatch: cannot convert from int to char
//		int sum = ch+ch1;
//		System.out.println(sum);// 131
		
//		char ch = 'A';
//		double d = 10.5;
//		int sum = ch+d;// Type mismatch: cannot convert from double to int
//		char sum1 = ch+d;// Type mismatch: cannot convert from double to char
//		double sum = ch+d;// 75.5
//		System.out.println(sum);

//		System.out.println('a'+'b');//195
//		System.out.println('a'+10.5);// 107.5
//		System.out.println('a'+0.89);// 97.89
		
//		System.out.println(10/0);// java.lang.ArithmeticException: / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(-10/0.0);// -Infinity
		
//		System.out.println(10/0.0f);// Infinity
//		System.out.println(-10/0.0f);// -Infinity
		
//		System.out.println(10/0);// / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(10.0/0);// Infinity
//		System.out.println(-10.0/0);// -Infinity
		
		
		
//		 NaN- Not a Number
		
//		System.out.println(0/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(0/29);//0
		
//		System.out.println(0/0.0f);// NaN
//		System.out.println(-0/0.0f);// NaN
		
//		System.out.println(0/0.0);// NaN
//		System.out.println(-0/0.0);// NaN
	
//		System.out.println(0/0);//java.lang.ArithmeticException: / by zero
		
//		System.out.println(0.0/0);// NaN
//		
//		System.out.println(-0.0/0);// NaN
		
//		Summary
		
//		System.out.println(10/0); / by zero
//		System.out.println(10/0.0);// Infinity
//		System.out.println(0/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(0.0/0);// NaN
		
//		System.out.println(10<Float.NaN);// false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN == Float.NaN);// false
//		System.out.println(10 != Float.NaN);// true
//		System.out.println(Float.NaN != Float.NaN);// true
		
		// need to study further on NaN 
		
		
		
//		2. String Concatenation operator:(+) lecture 18
		
//		String a = "Fahad";
//		int b=10,c=20,d=30;
//		System.out.println(a+b+c+d);// Fahad102030
//		System.out.println(b+c+d+a);// 60Fahad
//		System.out.println(b+c+a+d);// 30Fahad30
//		System.out.println(b+a+c+d);// 10Fahad2030
		
//		System.out.println(a=a+b+c);//Fahad1020
//		System.out.println(a=b+c+d);// Type mismatch: cannot convert from int to String
//		System.out.println(b=a+c+d);// Type mismatch: cannot convert from String to int
//		System.out.println(b=b+c+d);// 60
		
//		4. relational Operator (<,<=,>,>=)
//		System.out.println(10<20);// true
//		System.out.println('a'<20);//false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'<'A');// false
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		System.out.println("fahad102">"fahad");//The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5. Equality operator (==, !=)
		
		
	
		
		
//		--------Revision Practice -----------------------------------------------------------------------------
		
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
//		
//		int x= 10;
//		int y = ++x;
//		System.out.println(y);
//		int z = x++;
//		System.out.println(z);
//		int m = x++;
//		System.out.println(m);
		
		
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
//		
//		int x= 30;
//		int y= x++;
//		int z= ++x;
//		System.out.println(y); // 30
//		System.out.println(x); // 32
		
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
//		int x= 90;
//		int y= x++;
//		System.out.println(x);// 91
//		int y= ++x; //91
//		System.out.println(y);// 90
		
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
		
//		int x= 10;
//		int y= --x;
//		int z = x--;
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
		
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
//		int x= 10;
//		int y= 10++:
//		System.out.println(y);
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
		
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
		
//		int x= 10;
//  	int y= ++(x);
//		int z= ++(++x); // neasting of increment and decrement operators is not allowed.
//		System.out.println(z);
//		++x means value not a variable.. here we required variable not a valuex.
		
		
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		
//		final int x= 10;
//		int y = x++;
//		System.out.println(y);
		
		//The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
//		final int x= 10;
//		x=11;
//		System.out.println(x);
		
		
		
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
		
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
		
		
		
		
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // first assigned then increment.
//		
//		final int x= 10;
//		int y= x++;
//		System.out.println(y);
		
		
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
		
//		char ch = 'a';// a=97
//		ch++;
//		int y=ch;
//		System.out.println(ch);// b  becz value of a is 97 so after increment value becomes 98 which is value of b
//		System.out.println(y);// 98
		
//		double d= 10.9;
//		d++;
//		System.out.println(d);// 11.9
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
		
//		boolean b = false;
//		b++;// b+1-- (false+1)  Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		boolean b = false;
//		System.out.println(b);
		
		
		
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for every primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
		
//		If we applied any arithemetic operators between two variable a and b then
		//the result type is always	max of (int,type of a, type of b)
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+ b;// Type mismatch: cannot convert from int to byte
//		byte c= (byte) (a+b);
//		System.out.println(c);// 30
		
		
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
		
//		byte b =10;
//		b= b+1;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b=(byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11

//		byte b = 10;
//		b++;// internal typecasting happen by default
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr operator internal TypeCasting perform automatically
//		
//		byte b = 10;
//		byte c = 20;
//		byte d =(byte) (b+c);
//		System.out.println(d);// 30
		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->		float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97+0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(10/0);/ by zero
	
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two constatnt.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		System.out.println(10/0.0);
//		System.out.println(10.0/0.0);
//		System.out.println(10/-0.0);
//		System.out.println(-10/0.0);
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// / by zero
		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		System.out.println(10<Float.NaN);// false
		
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it is said arithmetic addition operators 
//		and sometime it is said string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
		
//		String a = "fahad";
//		int b=10,c=20,d=10;
//		System.out.println(a+b+c+d);//
//		System.out.println(b+c+d+a);
//		System.out.println(b+c+a+d);
//		System.out.println(b+a+c+d);
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		String a= "fahad";
//		int b=10, c=20, d=30;
////		a=b+c+d;
////		System.out.println(a);//Type mismatch: cannot convert from int to String
//		a=a+b+c;
////		System.out.println(a);
////		b=a+c+d;
//		b=b+c+d;
//		System.out.println(b);//60
		
		
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for every primitive type except boolean.
//		eg:-
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
//		
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'>'A');// true
//		System.out.println(true<false);
		
//		System.out.println(10<=10);// true
//		System.out.println(10>=10);// true
		
		
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println("fahad">"fahad");
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		System.out.println(10<20>30);// The operator > is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type including boolean also.
		
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
//		System.out.println(10==10);
//		System.out.println(10==20);
//		System.out.println('a'==97.0);
//		System.out.println('a'==97);
//		System.out.println('a'=='a');
//		System.out.println(false==false);// true
//		System.out.println('a'=='A');// false
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3 = t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);
//		System.out.println(O==S);
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
		
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1!=O);// true
//		System.out.println(O!=S);// true
//		System.out.println(S!=t1);// Incompatible operand types String and Thread
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		String S1 = new String("fahad");
//		String S2 = new String("fahad");
//		System.out.println(S1==S2);// false - address compare ho raha
//		System.out.println(S1.equals(S2)); // content/value compare ho rahi
//		
		
		
//		for any object reference r == null is always false
//		but null == null is always true
		
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		
//		String s = new String("durga");
//		System.out.println(s==null);// flase-- address compare and not matched so result is false.
		
//		String n = null;
//		System.out.println(n==null);// true.
//		System.out.println(null==null);// true
		
		
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to check whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);
//		System.out.println(t instanceof Object);
//		System.out.println(t instanceof Runnable);
		
//		int[] l = new int[9];
//		System.out.println(l[0]);
//		Object o = new l.get[0];
		
	
//		 ArrayList<String> l = new ArrayList<String>(); 
//		// Create an ArrayList object
//		 Object O = new l.get[0];
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		Thread t = new Thread();
//		System.out.println(t instanceof String);// Incompatible conditional operand types Thread and String
		
//		System.out.println(null instanceof Thread);// false
//		System.out.println(null instanceof Object);// false
//		System.out.println(null instanceof Runnable);// false
		
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		System.out.println(true & false); // false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false);// true
//		System.out.println(true ^ true);// false	
//		System.out.println(false ^ false);// false
		
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
//		System.out.println( 4 & 5);
//		System.out.println(4 |5);
//		System.out.println(4 ^ 5);
		
//		System.out.println(100 & 101);// 100
//		System.out.println(11 & 11); // 11
		
//		System.out.println(~4);// -5
		
//		System.out.println(~5);// -6
		
//		System.out.println(~38); // -39
		
		
		 
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		System.out.println(!10);
//		System.out.println(!true);
//		System.out.println(!false);
		
		
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
		
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
//		int x = 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		int x = 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16

//		int x = 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 & (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 | (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 | (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 || (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is responsible to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
//		int x= 'a';
//		System.out.println(x);// 97
//		
//		double d = 10;
//		System.out.println(d);// 10.0
		
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		float f = 10;
//		System.out.println(f);// 10.0
		
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		double d = 'a';
//		System.out.println(d);// 97.0
		
//		long l = 'a';
//		System.out.println(l);// 97
		
//		float f = 'a';
//		System.out.println(f);// 97.0
		
		
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		int x = 130;
//		byte b = (byte) x; //  cannot convert from int to byte
//		System.out.println(b);// -126
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
//		
//		int x = 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		int x = 150;
//		byte b= (byte)x;
//		System.out.println(b);// -106
		
//		int x = 509;
//		byte b = (byte)x;
//		System.out.println(b);// -3
		
//		int x = 509;
//		short s = (short)x;
//		System.out.println(s);// 509
		
		
		
		
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
		
//		double d = 130.456;
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		float f = 130.456f;
//		int x = (int)f;
//		System.out.println(x);// 130
		
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
//		int x = 10;
//		literal value 10 assigned to  var x
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
		
//		int a,b,c,d;
//		a=b=c=d=10;
//		System.out.println(a+".."+b+".."+c+".."+d);//10..10..10..10

//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);//20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator then we called that operator is CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		int a = 20;
//		a+=30;// -- a=a+30;
//		System.out.println(a);// 50

//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		byte b =10;
//		b=b+1;// cannot convert from int to byte
//		System.out.println(b);
//		
		
//		byte b = 10;
//		b++;
//		System.out.println(b);// 11

//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b =10;
//		b+=1; // b=b+1 
//		System.out.println(b);// 11

//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b =127;
//		b+=1;
//		System.out.println(b);// -128
		
//		byte b = 127;
//		b+=127;
//		System.out.println(b);//-2
		
//		byte b =127;
//		b+=129;
//		System.out.println(b);//0
		
//		byte b =127;
//		b+=130;
//		System.out.println(b);//1

//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		int a,c;
//		int b=20;
//		int d;
//		a=c=d=20;//chained
//		a+= 10;
//		b-=5;
//		c*=4;
//		d/=7;
//		System.out.println(a+"..."+b+"..."+c+"..."+d);//30...15...80...2
		
//		int a=10;
//		a+=a+10;
//		System.out.println(a);//30
		
//		int a=10;
//		a+=a+=a+=a-+a-+30;
//		System.out.println(a);
		
//		int a=10;
//		a+=12+12;
//		System.out.println(a);//34

//		int a,b,c,d,e,f,g,h;
//		a=b=c=d=e=f=g=h=10;
//		a+=10;
//		b-=10;
//		c/=10;// return quotient
//		d*=10;
//		e%=10; // return reminder
//		
//		f&=10; // f&10==> 10&10 = Ans 10 - 1010&1010==1010=10
//		g|=10; // 
//		h^=10;// x-OR cap 
//		
//		System.out.println(a); // 20
//		System.out.println(b); // 0
//		System.out.println(c); // 1
//		System.out.println(d); // 100
//		System.out.println(e); /// 0
//		System.out.println(f); // 10
//		System.out.println(g);// 10
//		System.out.println(h); // 0
		
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
		
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
//		
//		int x=  (10<20) ? 30 :40;
//		System.out.println(x);//30
		
//		int  x;
//		if(20<30) {
//			x=10;
//		}
//		else {
//			x=20;
//		}
//		System.out.println(x);// 10
		
		
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
		
//		int x =(10>20)?30 : (40>90)? 40 : 60;
//		System.out.println(x);// 60
		
//		int x= (10>=30)?30:40;
//		System.out.println(x);//40
		
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10==10) ? 50 :60;
//		System.out.println(x);// 50
		
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10==20) ? 50 :60;
//		System.out.println(x);// 60
			
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10!=10) ? 50 :(97.0==97) ?  60  :70;
//		System.out.println(x);// 60
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10!=10) ? 50 :(97.1==97) ?  60  :70;
//		System.out.println(x);// 70
		
		
		
//		System.out.println(10!=10);//falase
		
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
//		if(true&&false) {
//			System.out.println("Hii");
//		}
//		else
//		{
//			System.out.println("Hello");
//		}
//		// hello
		
//		if(10>20 && 30<40) {
//			System.out.println("Hii");
//		}else {
//			System.out.println("Hello");
//		}// Hello
		
		
//		if(true && true && true) {
//			System.out.println("Hello");
//		}else
//		{
//			System.out.println("Hello");
//		}// Hello
//		
//		if(true & true & true) {
//			System.out.println("Hello");
//		}else
//		{
//			System.out.println("Hello");
//		}// Hello
		
//		if(10<20 && 30<60 && 40<80 && 50<90 && 60<90) {
//			System.out.println("Hello");
//		}else {
//			System.out.println("Hii");
//		}// Hello
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executed to perform
//		initialization of object not for creation of object
		
//		
//		basically after creation of test class object by using new keyword constructor immideately execute (automatically) and perform initialization of created object
//		so, The  role of constructor is to perform initialization of object not creation of object.
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		int[] x = new int[10];
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=     .args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6));
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
//	    1+2*3/4+5*6*7/8+9-10
//		1+6/4+5*6*7/8+9-10
//		1+1+5*6*7/8+9-10
//		1+1+30*7/8+9-10
//		1+1+210/8+9-10
		1+1
		
//		If multiple operator has same precedence then it execute from left to right
//		and right to left accrdng to associativity.
		
//		For more detail : See Java operator precedence table
		
//		Lecture 23 : 
//		16.new vs newInstance()
//		1.new : - We can use this new operator to create an object , if we know classname at the beggining
//		eg:- 
//		Test t = new Test();
//		Student S = new Student();
//		Customer C = new Customer();
		
//		2. newInstance():- is a method in Class.class we can use newInstance method to create object, 
//		if we don't know class name at begining and it is available dynamically at runtime from
//		CLA,file,database.
//		eg: above
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError
//		both above 17 & 18 point are theory based and interview question only 
		
		
		
		


	}
//	public static int m1(int i) {
//	System.out.println(i);// 1,2,3,4,5,6
//	System.out.println(i);//1,2,3,4,5,6.7,8,9,10
//	return i;
//}
	
	public static int m1(int i) {
		System.out.println(i);
		return i;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 2 2024-01-01 23:28:33.318
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.ui".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.ui 4 0 2024-01-01 23:28:33.319
!MESSAGE Error in JDT Core during reconcile
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.AST.convertCompilationUnit(AST.java:521)
	at org.eclipse.jdt.internal.core.CompilationUnit.buildStructure(CompilationUnit.java:201)
	at org.eclipse.jdt.internal.core.Openable.generateInfos(Openable.java:266)
	at org.eclipse.jdt.internal.core.JavaElement.openWhenClosed(JavaElement.java:597)
	at org.eclipse.jdt.internal.core.CompilationUnit.makeConsistent(CompilationUnit.java:1142)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.makeConsistent(ReconcileWorkingCopyOperation.java:173)
	at org.eclipse.jdt.internal.core.ReconcileWorkingCopyOperation.executeOperation(ReconcileWorkingCopyOperation.java:94)
	at org.eclipse.jdt.internal.core.JavaModelOperation.run(JavaModelOperation.java:740)
	at org.eclipse.jdt.internal.core.JavaModelOperation.runOperation(JavaModelOperation.java:806)
	at org.eclipse.jdt.internal.core.CompilationUnit.reconcile(CompilationUnit.java:1319)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:131)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy$1.run(JavaReconcilingStrategy.java:93)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:90)
	at org.eclipse.jdt.internal.ui.text.java.JavaReconcilingStrategy.reconcile(JavaReconcilingStrategy.java:157)
	at org.eclipse.jdt.internal.ui.text.CompositeReconcilingStrategy.reconcile(CompositeReconcilingStrategy.java:94)
	at org.eclipse.jdt.internal.ui.text.JavaCompositeReconcilingStrategy.reconcile(JavaCompositeReconcilingStrategy.java:107)
	at org.eclipse.jface.text.reconciler.MonoReconciler.process(MonoReconciler.java:76)
	at org.eclipse.jface.text.reconciler.AbstractReconciler$BackgroundThread.run(AbstractReconciler.java:210)

!ENTRY org.eclipse.jdt.core 4 4 2024-01-01 23:28:33.387
!MESSAGE Exception occurred during compilation unit conversion:
----------------------------------- SOURCE BEGIN -------------------------------------
import java.util.ArrayList; 
	
public class OperatorsAndAssingments_Practice {
	//class Customer{
//	
//}
//class Test{
//	public static void main(String[] args)throws Exception {
//		Object O = Class.forName(args[0]).newInstance();
//		System.out.println("Object created for :"+O.getClass().getName());
////		System.out.println("Hello");
//- Other rest thing are thoery based and need setting for runnig in run time nad compile time seperately
//	}
//}
	public static void main(String[] args) {
//		Types of operators:-
//		1.Increment and decrement operators
//		2.Arithmetic operators
//		3.String concatenation operators
//		4.Relational operators
//		5.Equality operators
//		6.instanceOf operators
//		7.bitwise operators
//		8.short circuit operators
//		9.type cast operators
//		10.Assignment operators
//		11.conditional operators
//		12.new operators
//		13.[] operators
//		14.operator precedence
//		15.Evaluation order of operands
//		16.new vs newInstance()
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError

//		1. Increment & Decrement operators:-
//		Increment - Pre-Increment , y=++x;
//		Increment - Post-Increment, y=x++;
		
//		Decrement - Pre-Decrement , y=--x;
//		Decrement - Post-Decrement, y=x--;
		
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		Pre Increment
//		int x= 10;
//		int y= ++x;// pre incr -- here y value = 11
//		System.out.println(x);// 11
//		System.out.println(y);// 11
		
//		Post Increment
//		int x= 10;
//		int y= x++;
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		
//		int x= 10;
//		int y= x+1;
//		System.out.println(x);// 10
//		System.out.println(y);// 11
		
//		Pre Decrement
//		int x= 10;
//		int y= --x;
//		System.out.println(y);// 9
//		System.out.println(x);// 9
		
//		Post Decrement
//		int x= 10;
//		int y= x--;
//		System.out.println(y);// 10
//		System.out.println(x);// 9
		
//		int x= 10;
//		int y= ++10;// Invalid argument to operation ++/--
//		System.out.println(x);
////		System.out.println(y);
//		int z = 10++;// Invalid argument to operation ++/--
//		System.out.println(z);
		
		
//		int x= 10;
//		int y= ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		final int x = 10;
//		x++;// The final local variable x cannot be assigned. 
////		It must be blank and not using a compound assignment
//		System.out.println(x);
		
		
//		final int x = 10;
//		x++;
//		System.out.println(x);// The final local variable x cannot be assigned. It must be blank and not using a compound assignment
		
//		int x = 10;
//		x++;
//		System.out.println(x);
		
//		int x= 10;
//		int y= x++;
//		int z = x;
//		z++;
//		
//		System.out.println(y);// 10
//		System.out.println(x);// 11
//		System.out.println(z);// 12
		
//		int x = 10;
//		int y = ++x;
//		int z= y;
//		System.out.println(z);// 11
//		z++;
//		System.out.println(y);// 11
//		System.out.println(x);// 11
//		System.out.println(z);// 12
	
//		int x= 10;
//		x++;
//		System.out.println(x);// 11
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		char ch = 'a';
//		ch++;
//		System.out.println(ch);// b
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		double d = 10.5;
//		++d;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;// Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		char ch = 'a';
//		char y = ch++;
//		System.out.println(ch);//b
//		System.out.println(y);//a
		
		
		
		
		
//		Diff Btwen b++ and b=b+1
		
//		byte b = 10;
//		byte a= 10;
//		byte c= a+b;// max(int,type of a, type of b)--> max(int,byte,byte)
//		System.out.println(c);//Type mismatch: cannot convert from int to byte
		
//		byte a = 10;
//		byte b = -1;
//		byte c= (byte)(a+b);
//		System.out.println(c);//9
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = a+b;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		int b = 10;
//		int a= 10;
//		int c = a+b; // max(int,type of a, type of b)--> max(int,int,int)
//		System.out.println(c);// 20
		
//		short a = 10;
//		short b = 10;
//		short c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to short
		
//		short a = 10;
//		short b = 10;
//		short c = (short)(a+b);
//		System.out.println(c);// 20
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = ch + ch1;
//		System.out.println(chs);// Type mismatch: cannot convert from int to char
		
//		char ch = 'a';
//		char ch1 = 'b';
//		char chs  = (char)(ch + ch1);
//		System.out.println(chs);//
		
//		char ch2 = '';
//		int in = ch2+0;
//		System.out.println(in);
		
		
//		char ch = 'a';
//		char ch1 = 'b';
//		int x = ch;
//		int y= ch1;
//		System.out.println(x);//97
//		System.out.println(y);//98
		
//		char x = 'a';
//		char y= 'b';
//		long l = x+y;
//		System.out.println(l);// 197
		
//		char x= 'a';
//		char y='b';
//		float f= x+y;
//		System.out.println(f);// 195.0
		
//		char x= 'a';
//		char y='b';
//		double d= x+y;
//		System.out.println(d);// 195.0
		
//		char ch = 'a';
//		double d = 10.5d;
//		double sum = ch +d;
//		System.out.println(sum);// 107.5
		
//		char ch = 'a';
//		double d = 10.5d;
//		int sum = (int)(ch +d);
//		System.out.println(sum);// 107
		
		
		
		
		
		
//		byte b= 10;
//		byte a = 10;
//		byte c = (byte)(a+b);// Type mismatch: cannot convert from int to byte
//		System.out.println(c);// 20
		
//		byte b= 10;
//		byte a = 20;
//		byte c = a + b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);
		
//		byte b= 10;
//		byte a = 20;
//		byte c = (byte)(a + b);
//		System.out.println(c);
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b= (byte)(b+1+b);
//		System.out.println(b);// 21
		
//		byte b = 10;
//		b= (byte)(b+1+b-b+10-12);
//		System.out.println(b);// 9
		
//		byte b = 10;
//		b= (byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b =20;
//		b= b+1;
//		System.out.println(b);
		
//		byte c = 20;
//		c= c++;
//		System.out.println(c);//20
		
		
//		int a = 10;
//		int c = 10;
//		byte z = (byte)(a+c);
//		System.out.println(z);
		
		
		
//		int x= 10;
//		int y = ++ (++x);// Invalid argument to operation ++/--
//		System.out.println(y);
		
//		int x= 10;
//		int y= ++ (++x);
//		System.out.println(y);// Invalid argument to operation ++/--
		
		
		
		
		
//		byte c = 20;
//		byte z = c++;
//		System.out.println(z);//20
		
//		byte b = 10;
//		b++;// (byte)b+1
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11
		
		
		
		
//		2. Arithematic Operator - (+,-,*,/,%)
		
//		byte b = 10;
//		byte c = 19;
//		byte sum = (byte)(b+c) ;
//		System.out.println(sum);// 29
		
		
//		byte b = 10;
//		short s = 19;
//		short sum = (short)(b+s);
//		System.out.println(sum);// 29
		
//		short s1 = 10;
//		short s2= 18;
//		short sum = (short)(s1+s2);
//		System.out.println(sum);// 28
		
//		byte b = 10;
//		long l = 19;
//		long sum = b+l;
//		System.out.println(sum);// 29  -- int to long conversion is possible 
		
//		long l = 10;
//		double d = 10.4;
//		double sum = l+d;
//		System.out.println(sum);// 20.4 -- int to double is possible and long is max among
		
		
//		float f = 10.4f;
//		long l = 10;
//		long sum = f+l;// Type mismatch: cannot convert from float to long
//		long sum = (long)(f+l);// 20-- ans in long
//		float sum = l+f;// 20.4
//		System.out.println(sum);
		
//		char ch = 'A';
//		char ch1 = 'B';
//		char sum = ch+ch1;// Type mismatch: cannot convert from int to char
//		int sum = ch+ch1;
//		System.out.println(sum);// 131
		
//		char ch = 'A';
//		double d = 10.5;
//		int sum = ch+d;// Type mismatch: cannot convert from double to int
//		char sum1 = ch+d;// Type mismatch: cannot convert from double to char
//		double sum = ch+d;// 75.5
//		System.out.println(sum);

//		System.out.println('a'+'b');//195
//		System.out.println('a'+10.5);// 107.5
//		System.out.println('a'+0.89);// 97.89
		
//		System.out.println(10/0);// java.lang.ArithmeticException: / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(-10/0.0);// -Infinity
		
//		System.out.println(10/0.0f);// Infinity
//		System.out.println(-10/0.0f);// -Infinity
		
//		System.out.println(10/0);// / by zero
		
//		System.out.println(10/0.0);// Infinity
//		System.out.println(10.0/0);// Infinity
//		System.out.println(-10.0/0);// -Infinity
		
		
		
//		 NaN- Not a Number
		
//		System.out.println(0/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(0/29);//0
		
//		System.out.println(0/0.0f);// NaN
//		System.out.println(-0/0.0f);// NaN
		
//		System.out.println(0/0.0);// NaN
//		System.out.println(-0/0.0);// NaN
	
//		System.out.println(0/0);//java.lang.ArithmeticException: / by zero
		
//		System.out.println(0.0/0);// NaN
//		
//		System.out.println(-0.0/0);// NaN
		
//		Summary
		
//		System.out.println(10/0); / by zero
//		System.out.println(10/0.0);// Infinity
//		System.out.println(0/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(0.0/0);// NaN
		
//		System.out.println(10<Float.NaN);// false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN == Float.NaN);// false
//		System.out.println(10 != Float.NaN);// true
//		System.out.println(Float.NaN != Float.NaN);// true
		
		// need to study further on NaN 
		
		
		
//		2. String Concatenation operator:(+) lecture 18
		
//		String a = "Fahad";
//		int b=10,c=20,d=30;
//		System.out.println(a+b+c+d);// Fahad102030
//		System.out.println(b+c+d+a);// 60Fahad
//		System.out.println(b+c+a+d);// 30Fahad30
//		System.out.println(b+a+c+d);// 10Fahad2030
		
//		System.out.println(a=a+b+c);//Fahad1020
//		System.out.println(a=b+c+d);// Type mismatch: cannot convert from int to String
//		System.out.println(b=a+c+d);// Type mismatch: cannot convert from String to int
//		System.out.println(b=b+c+d);// 60
		
//		4. relational Operator (<,<=,>,>=)
//		System.out.println(10<20);// true
//		System.out.println('a'<20);//false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'<'A');// false
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
		
//		System.out.println("fahad102">"fahad");//The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		5. Equality operator (==, !=)
		
		
	
		
		
//		--------Revision Practice -----------------------------------------------------------------------------
		
		
//		int x = 10;
//		int y=++x; // Pre-Increment
//		int z =x++; // 11 // Post-Increment
//		System.out.println(y); // 11 - OP
//		System.out.println(z); // 11
//		int m =x++; // 11
//		System.out.println(m); // 11
//		
//		int x= 10;
//		int y = ++x;
//		System.out.println(y);
//		int z = x++;
//		System.out.println(z);
//		int m = x++;
//		System.out.println(m);
		
		
		
//		int x=20;
//		int y= ++x; // Isi line me value incr ho gayi //Pre-Increment
//		System.out.println(y); // 21
//		System.out.println(x); // 21
//		
//		int x= 30;
//		int y= x++;
//		int z= ++x;
//		System.out.println(y); // 30
//		System.out.println(x); // 32
		
		
//		int x= 30;
//		int y= x++; // Post-Increment
//		System.out.println(y); // 30 Post-Increment
//		System.out.println(x); // 31 Post-Increment
//		int x= 90;
//		int y= x++;
//		System.out.println(x);// 91
//		int y= ++x; //91
//		System.out.println(y);// 90
		
		
//		int y=20;
//		int x= --y; //Pre-Decrement
//		System.out.println(x); // 19 Pre-Decrement 
//		System.out.println(y); //19  Pre-Decrement
		
//		int z= 20;
//		int x= z--; // Post-Decrement
//		System.out.println(x); // 20 Post-Decrement
//		System.out.println(z); // 19 Post-Decrement
		
//		int x= 10;
//		int y = x++;
//		System.out.println(y); // 10
//		System.out.println(x);// 11
//		int z= --x;
//		System.out.println(z); // 10
		
//		int x= 10;
//		int y= --x;
//		int z = x--;
//		System.out.println(y);
//		System.out.println(z);
//		System.out.println(x);
		
//		We cant apply incremnt and decrement operators on constant values.
//		int x = 10;
//		int y = ++10;
//		System.out.println(y);// Unresolved compilation problem: 
//		int x= 10;
//		int y= 10++:
//		System.out.println(y);
		//Invalid argument to operation ++/--
//		Nesting of INC/DEC operators is not allowed
		
//		int x= 10;
//		int y= ++(++x);
//		System.out.println(y); // Unresolved compilation problem: 
		//Invalid argument to operation ++/--
		
//		int x= 10;
//  	int y= ++(x);
//		int z= ++(++x); // neasting of increment and decrement operators is not allowed.
//		System.out.println(z);
//		++x means value not a variable.. here we required variable not a valuex.
		
		
//		For FINAL variables we cant apply incr/decr operators.
//		final int x = 10;
//		x++;// Unresolved compilation problem: 
//		int y= x++;// Unresolved compilation problem: 
//		System.out.println(y);// Unresolved compilation problem: 
		
//		final int x= 10;
//		int y = x++;
//		System.out.println(y);
		
		//The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
//		final int x= 10;
//		x=11;
//		System.out.println(x);
		
		
		
//		final int x =10;
//		x=11;// Unresolved compilation problem: 
//		System.out.println(x);// The final local variable x cannot be assigned.
//		It must be blank and not using a compound assignment
		
		
//		int x = 10;
//		x++;
//		int y=x++;//10
//		System.out.println(y);// 11
//		System.out.println(x);// 12
		
		
		
		
//		int x = 10;
//		x++;
//		System.out.println(x);// 11
//		int y=x++;
//		System.out.println(y);// 11
//		System.out.println(x);// 12
//		System.out.println(y);// 11 // first assigned then increment.
//		
//		final int x= 10;
//		int y= x++;
//		System.out.println(y);
		
		
//		char ch = 'a';
//		ch++;
//		int y= ch;
//		System.out.println(ch); // b
//		System.out.println(y); //98
		
//		char ch = 'a';// a=97
//		ch++;
//		int y=ch;
//		System.out.println(ch);// b  becz value of a is 97 so after increment value becomes 98 which is value of b
//		System.out.println(y);// 98
		
//		double d= 10.9;
//		d++;
//		System.out.println(d);// 11.9
		
//		double d = 10.5;
//		d++;
//		System.out.println(d);// 11.5
		
//		boolean b = true;
//		b++;
//		System.out.println(b);// Type mismatch: cannot convert from boolean to int
		
//		boolean b = false;
//		b++;// b+1-- (false+1)  Type mismatch: cannot convert from boolean to int
//		System.out.println(b);
		
//		boolean b = false;
//		System.out.println(b);
		
		
		
//		operator ++ can not applied to boolean
//		?We can apply inc/decr operators for every primitive data type only except to boolean
//		
		//Date&Time=04:03PM,Wednesday,02/08/2023 START
//		
//		5. Diff btwn B++ & b=b+1 
		
//		If we applied any arithemetic operators between two variable a and b then
		//the result type is always	max of (int,type of a, type of b)
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+b;
//		System.out.println(c);// Type mismatch: cannot convert from int to byte
//		we can solve/handle it by usinf type casting
//		byte c = (byte)(a+b);
//		System.out.println(c);// 30
		
//		byte a = 10;
//		byte b = 20;
//		byte c = a+ b;// Type mismatch: cannot convert from int to byte
//		byte c= (byte) (a+b);
//		System.out.println(c);// 30
		
		
//		byte b = 10;
//		b= b+1;// Type mismatch: cannot convert from int to byte
//		System.out.println(b);//Type mismatch: cannot convert from int to byte
		
//		byte b =10;
//		b= b+1;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		byte b = 10;
//		b=(byte)(b+1);// using TypeCasting
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b=(byte)(b+1);
//		System.out.println(b);// 11
		
//		byte b = 10;
//		b++;
//		System.out.println(b);//11

//		byte b = 10;
//		b++;// internal typecasting happen by default
//		System.out.println(b);// 11
//		NOTE:- In case of INcr/Decr operator internal TypeCasting perform automatically
//		
//		byte b = 10;
//		byte c = 20;
//		byte d =(byte) (b+c);
//		System.out.println(d);// 30
		
		
//		2.Arithmetic Opeartors:-(+,-,/,*,%)
//		If we apply any arithmetic opearators between a&b the result type is always
//		max(int,type of a , type of b)
//		
//		Fig: Typecasting flow
//		byte--->Short---->
//						----->int-->long-->		float-->double
//				char---->
		
//		byte + byte= int
//		byte + short= int
//		short + short=int
//		byte + long=long
//		long + double=double
//		float + long=float
//		char + char=int
//		char + double=double
		//Date&Time=04:23PM,Wednesday,02/08/2023 END
		
		//Date&Time=05:45PM,Wednesday,02/08/2023 START
//		System.out.println('a'+0.89);// 97.89-->a=97 (ASCII Value) -->97+0.89=97.89 double// char + double=double
//		byte b = 6;
//		byte c = 6;
//		System.out.println(b+c);// 12 jo ki int hai= byte + byte= int
//		System.out.println(32767+32767);// 65534 is int value short + short=int
//		System.out.println(127+32767);// 32894     byte + short= int
//		System.out.println(127+23717372);// 23717499 byte + long=long
//		System.out.println(1234531+10.3333);//1234541.3333 //long + double=double
//		System.out.println(212.332+932049832);// 9.32050044332E8 // float + long=float
//		System.out.println('a'+'a');// 194 char + char=int
//		System.out.println('a'+765.27);// 862.27  char + double=double
		
//		Infinity:-
//		In integral arithmetic(byte,short,int ,long) there is no way to represent infinity if infinity is a result then we will get AE: in integral arithmetic
//		
//		System.out.println(10/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(10/0);/ by zero
	
//		But in floating point arithmetic (float & double) there is a way to represent infinity
//		for this float & double classes conatins the following two constatnt.
//		POSITIVE_INFINITY
//		NEGATIVE_iNFINITY
//		Hence even though result is infinity we wont get nay arithmetic exception in floating point arithmetic
//		
//		eg:-
//		System.out.println(10/0.0);// Infinity 10/float/double
//		System.out.println(10.0/0);// Infinity float/double/0
		
//		System.out.println(10/0.0);
//		System.out.println(10.0/0.0);
//		System.out.println(10/-0.0);
//		System.out.println(-10/0.0);
		
//		NaN:-(Not a number)
//		In integral arithmetic(byte,short,int ,long) there is no way to represent undefined result 
//		if undefined is a result then we will get AE: in integral arithmetic
//		Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// Exception in thread "main" java.lang.ArithmeticException: / by zero
//		
//		System.out.println(0/0);// / by zero
		
//		But in floating point arithmetic (float & double) there is a way to represent undefined result
//		for this float & double classes contains NaN constant.
//		Hence if the result is undefined we won't get any AE. in floating point arithmetic
//		
//		System.out.println(0.0/0);// NaN
//		System.out.println(-0/0.0); // NaN
//		System.out.println(10/0);//  java.lang.ArithmeticException: / by zero
//		System.out.println(-10/0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10/-0);// java.lang.ArithmeticException: / by zero
//		System.out.println(10.0/0);// Infinity
//		System.out.println(10.0/-0);// Infinity
//		System.out.println(-10.0/-0);// -Infinity
//		System.out.println(-10.0/0);// -Infinity
//		System.out.println(10.0/-0.0);// -Infinity
//		System.out.println(-10.0/-0.0); // Infinity
//		System.out.println(0.0/-0);// NaN
//		System.out.println(-0.0/0);// NaN
//		System.out.println(-0.0/-0);// NaN
//		System.out.println(-1.0/-0);// -Infinity
		
//		for any x value including NaN the following expression return false
//		int x =0;
//		System.out.println(x<NaN); // NaN cannot be resolved to a variable
//		System.out.println(x<=NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>NaN); // NaN cannot be resolved to a variable
//		System.out.println(x>=NaN);  // NaN cannot be resolved to a variable
//		System.out.println(x==NaN);// NaN cannot be resolved to a variable
		
//		for any x value including NaN the following expression return true
//		System.out.println(x!=NaN);// x cannot be resolved to a variable
		//NaN cannot be resolved to a variable
		
//		System.out.println(10<float.NaN); // Syntax error on token "float", invalid Expression
		
//		System.out.println(10<Float.NaN); // false
//		System.out.println(10<=Float.NaN);// false
//		System.out.println(10>Float.NaN);// false
//		System.out.println(10>=Float.NaN);// false
//		System.out.println(10==Float.NaN);// false
//		System.out.println(Float.NaN==Float.NaN);// false
//		System.out.println(10!=Float.NaN);// true
//		System.out.println(Float.NaN!=Float.NaN);// true
		
//		System.out.println(10<Float.NaN);// false
		
		
//		3.String concatenation operators
		
//		The only overloaded operator in java is (+) operator. 
//		Sometime it is said arithmetic addition operators 
//		and sometime it is said string concatenation opeartors.
		
		
//		Case1:-
//		If atleast one argument is String type  then
//		(+) operator access String concatenation operator.
		
//		Case2:-
//		If both argument is number type  then
//		(+) operator access arithmetic addition operator.
		
//		eg1:-
//		String a = "fahad";
//		int b=10, c=20, d=10;
//		System.out.println(a+b+c+d);// fahad102010 String concatenation operator
//		System.out.println(b+c+d+a);//40fahad this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+c+a+d);// 30fahad10 this expression has same operator then order of precedence is from left to right so it start add value from left and concat with a. So it use both String concatenation operator and arithmetic addition operator 
//		System.out.println(b+a+c+d);// 10fahad2010
		
		
//		String a = "fahad";
//		int b=10,c=20,d=10;
//		System.out.println(a+b+c+d);//
//		System.out.println(b+c+d+a);
//		System.out.println(b+c+a+d);
//		System.out.println(b+a+c+d);
		
//		eg2:-
//		String a = "fahad";
//		int b=10, c=20, d=30;
//		a=b+c+d;
//		System.out.println(a); // Type mismatch: cannot convert from int to String
//		a=a+b+c;
//		System.out.println(a);// fahad1020
//		b=a+c+d;
//		System.out.println(b);// Type mismatch: cannot convert from String to int
//		b=b+c+d;
//		System.out.println(b);// 60
		
//		String a= "fahad";
//		int b=10, c=20, d=30;
////		a=b+c+d;
////		System.out.println(a);//Type mismatch: cannot convert from int to String
//		a=a+b+c;
////		System.out.println(a);
////		b=a+c+d;
//		b=b+c+d;
//		System.out.println(b);//60
		
		
		
//		4.Relational operators (<,<=,>,>=)
//		We can apply relational operator for every primitive type except boolean.
//		eg:-
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6); //true
//		System.out.println('a'>'A'); // true
//		System.out.println(true>false);// The operator > is undefined for the argument type(s) boolean, boolean
//		
//		System.out.println(10<20);// true
//		System.out.println('a'<20);// false
//		System.out.println('a'<97.6);// true
//		System.out.println('a'>'A');// true
//		System.out.println(true<false);
		
//		System.out.println(10<=10);// true
//		System.out.println(10>=10);// true
		
		
		
//		 We cannot apply relational operators for object/Non-Primitive types
//		eg
//		System.out.println("durga123">"durga");// The operator > is undefined for the argument type(s) java.lang.String, java.lang.String
		
//		System.out.println("fahad">"fahad");
		
//		Nesting of relational operator is not allowed otherwise we will get CTE.
//		System.out.println(10<20<30);// The operator < is undefined for the argument type(s) boolean, int
		
//		System.out.println(10<20>30);// The operator > is undefined for the argument type(s) boolean, int
		
//		5.Equality operators (==, !=)  //Date&Time=3:43PM,Friday,02/10/2023
//		we can use == operator for address comparison
		
//		we can  apply equality operator for every primitive type including boolean also.
		
//		System.out.println(10==20);// false
//		System.out.println('a'=='b'); // false
//		System.out.println('a'==97.0); //true
//		System.out.println(false==false);// true
//		System.out.println(true==true);// true
//		System.out.println('a'=='A');// false
//		System.out.println('a'==97);// true
//		System.out.println(127==127);// true
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false// yahan address compare nahi ho raha.
		
//		System.out.println(10==10);
//		System.out.println(10==20);
//		System.out.println('a'==97.0);
//		System.out.println('a'==97);
//		System.out.println('a'=='a');
//		System.out.println(false==false);// true
//		System.out.println('a'=='A');// false
//		System.out.println("fahad"=="fahad");// true
//		System.out.println("fah"=="abd");// false
		
//		we can apply equality operator for object type also
//		for object references r1 and r2 , r1== r2 iff both reference pointing to the same object
//		(reference comparison or address comparison)
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3=t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Thread t2 = new Thread();
//		Thread t3 = t1;
//		System.out.println(t1==t3);// true
//		System.out.println(t1==t2);// false
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);// false
//		System.out.println(O==S);// false
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1==O);
//		System.out.println(O==S);
//		System.out.println(S==t1);// Incompatible operand types String and Thread
		
		
		
//		!= operators
//		we can use != operator for address comparison
//		System.out.println(10!=20);// true
//		System.out.println('a'!='b'); // true
//		System.out.println('a'!=97.0); //false
//		System.out.println(false!=false);// false
//		System.out.println(true!=true);// false
//		System.out.println('a'!='A');// true
//		System.out.println('a'!=97);// false
//		System.out.println(127!=127);// false
//		System.out.println("fahad"!="fahad");// false
//		System.out.println("fah"!="abd");// true
		
//		Thread t1 = new Thread();
//		Object O = new Object();
//		String S = new String("durga");
//		System.out.println(t1!=O);// true
//		System.out.println(O!=S);// true
//		System.out.println(S!=t1);// Incompatible operand types String and Thread
		
		// In general we can use == operator for address comparison 
//		and .equals() method for content comparison.
		
//		eg:
//		String S1 = new String("durga");
//		String S2= new String("durga");
//		System.out.println(S1==S2);//false // this compare address of variable/object
//		System.out.println(S1.equals(S2));// true// this method compare content of variable/objects
		
//		String S1 = new String("fahad");
//		String S2 = new String("fahad");
//		System.out.println(S1==S2);// false - address compare ho raha
//		System.out.println(S1.equals(S2)); // content/value compare ho rahi
//		
		
		
//		for any object reference r == null is always false
//		but null == null is always true
		
//		String s = new String("durga");
//		System.out.println(s==null);// flase
//		
//		String s = new String("durga");
//		System.out.println(s==null);// flase-- address compare and not matched so result is false.
		
//		String n = null;
//		System.out.println(n==null);// true.
//		System.out.println(null==null);// true
		
		
//		String n = null;
//		System.out.println(n==null);// true
//		System.out.println(null==null);// true
		
//		Lecture 19:- 
//		6.instanceOf operators
		//Date&Time=01:03PM,Friday,02/10/2023
//		We  can use instanceof operator to check whether given object is of particular type or not.
		
//		Syntax:-
//		r instance X -- r is object reference  X is class or interface name
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);// true
//		System.out.println(t instanceof Object);  // true
//		System.out.println(t instanceof Runnable);// true
		
//		Thread t = new Thread();
//		System.out.println(t instanceof Thread);
//		System.out.println(t instanceof Object);
//		System.out.println(t instanceof Runnable);
		
//		int[] l = new int[9];
//		System.out.println(l[0]);
//		Object o = new l.get[0];
		
	
//		 ArrayList<String> l = new ArrayList<String>(); 
//		// Create an ArrayList object
//		 Object O = new l.get[0];
		
//		for any class or interface X null instanceof X  is always false
//		System.out.println(null instanceof Thread); // false
//		System.out.println(null instanceof Runnable);// false
		
		
//		Thread t = new Thread();
//		System.out.println(t instanceof String);// Incompatible conditional operand types Thread and String
		
//		System.out.println(null instanceof Thread);// false
//		System.out.println(null instanceof Object);// false
//		System.out.println(null instanceof Runnable);// false
		
		
		
//		7.bitwise operators (&, |, ^)
//		 & -- And,  returns true iff both arguments are true
//		 | -- OR  returns true iff atleast one arguments are true
//		 cap symbol - ^ -- Exor, exclusive OR, X-OR, returns true iff both arguments are different
		
//		eg :- 
//		System.out.println(true & false);// false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false); // true
		
//		System.out.println(true & false); // false
//		System.out.println(true | false);// true
//		System.out.println(true ^ false);// true
//		System.out.println(true ^ true);// false	
//		System.out.println(false ^ false);// false
		
		
//		we can apply these for integral types also
//		System.out.println(4&5);// 4
//		System.out.println(4|5);// 5
//		System.out.println(4^5);// 1
		
//		System.out.println( 4 & 5);
//		System.out.println(4 |5);
//		System.out.println(4 ^ 5);
		
//		System.out.println(100 & 101);// 100
//		System.out.println(11 & 11); // 11
		
//		System.out.println(~4);// -5
		
//		System.out.println(~5);// -6
		
//		System.out.println(~38); // -39
		
		
		 
		
//		bitwise complement operators (~):- tild symbol
//		We can apply for only integral type not for boolean type OW CTE.
//		System.out.println(~true);  // The operator ~ is undefined for the argument type(s) boolean
//		System.out.println(~4);// -5
		
//		Boolean complement operator : (!)--
//		We can apply this operator only for boolean type but not for integarl types.
//		System.out.println(!8);// The operator ! is undefined for the argument type(s) int
//		System.out.println(!false);// true
//		System.out.println(!true);// false
		
//		System.out.println(!10);
//		System.out.println(!true);
//		System.out.println(!false);
		
		
		
//		Note :-
//		&,|,^-- applicable for both boolean & integral
//		~ -- applicable for only integral but not for boolean
//		!  applicable only for boolean but not for integral
		
		
		
//		8.short circuit operators :(&&, ||)
		
//		These are exactly same as bitwise operators(&,|) except only following differences.
		
//				$,|		|		&&,||
//		-------------------------------				
//		1.Both argument	|	1. second argument		
//		should be evalu	|		evaluation is optional	
//		ated always.	|			
//		
//		2.relatively	|	2.relatively performance
//		performance 	|	high
////	low
//		
//		3.applicable	|	3. applicable only for boolean but not
//		for both boolean |	for integral
//		and integral types|
						
//		Note:- 1. x&&y == y will be evaluated iff x is true i.e. if x is false then y will not be evaluated.
		
//		2.  x||y - y will be evaluated iff x is false i.e. if x is true then y will not be evaluated.
			
//		eg_
//		int x= 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...17
		
//		int x = 10;
//		int y=15;
//		if(++x<10 & ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
//		int x= 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16
		
//		int x= 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		
//		int x= 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
		
//		int x = 10;
//		int y=15;
//		if(++x<10 && ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 11...16

//		int x = 10;
//		int y=15;
//		if(++x<10 | ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);// 12...16
		
//		int x = 10;
//		int y=15;
//		if(++x<10 || ++y>15) {
//			x++;
//		}else {
//			y++;
//		}
//		System.out.println(x+"..."+y);
		
		
//		eg:- 2-
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// o/p:- Hii
//		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}// : / by zero
		
//		int x= 10;
//		if(++x<10 && (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 & (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 & (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 | (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
		
//		int x= 10;
//		if(++x<10 | (x/2>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		int x= 10;
//		if(++x<10 || (x/0>10)) {
//			System.out.println("Hello !!");
//		}else {
//			System.out.println("Hii !!");
//		}
		
//		9.type cast operators
		
//		1. Implicit typecasting
//		2. Explicit Typecasting
		
//		1.Implicit:
//		Compiler is responsible to perform ITC.
//		whenever we are assinging smaller Datatype value to bigger datatype variable ITC will be performed.
//		It is also known as widening and upcasting
//		There is no loss of information in this typecasting
//		The following are various possible conversion where ITC will be performed.
		
//		Fig: Typecasting flow : ITC
//		byte--->Short---->
//						----->int-->long-->float-->double
//				char---->
		
//		eg:-
//		int x='a'; 
//		System.out.println(x);// 97// compiler convert char to int automatically by ITC
//		int x= 'a';
//		System.out.println(x);// 97
//		
//		double d = 10;
//		System.out.println(d);// 10.0
		
//		long l = 10;
//		System.out.println(l);// 10
		
		
//		float f = 10;
//		System.out.println(f);// 10.0
		
		
//		double d = 10;
//		System.out.println(d);// 10.0  compiler convert int to double automatically by ITC
		
//		double d = 'a';
//		System.out.println(d);// 97.0
		
//		long l = 'a';
//		System.out.println(l);// 97
		
//		float f = 'a';
//		System.out.println(f);// 97.0
		
		
		
//		2.Explicit Type casting:
//		Programmer is responsible to perform ETC.
//		whenever we are assinging bigger Datatype value to smaller datatype variable then  ETC will be required.
//		It is also known as narrowing and downcasting
//		There may a chance of loss of information in this typecasting
		
//		The following are various possibilities  where ETC will  required.
		
//		Fig: ETC
//		byte<---Short<----
//						<-----int<--long<--float<--double
//				char<----
		
//		L---R -- Implicit TypeCasting
//		R---L -- Explicit Typecasting
		
//		eg:-
//		int x = 130;
//		byte b = x;
//		System.out.println(b);// Type mismatch: cannot convert from int to byte
		
//		int x = 130;
//		byte b = (byte) x; //  cannot convert from int to byte
//		System.out.println(b);// -126
		
		
//		int x = 130;
//		byte b = (byte)x;
//		System.out.println(b);// -126
		
//		whenever we are assingnig bigger D.T value to smaller D.T variable by ETC The MSB will be lost
//		We have to consider only LSB
		
//		int x= 150;
//		short s = (short)x;
//		System.out.println(s);// 150
//		
//		int x = 150;
//		short s = (short)x;
//		System.out.println(s);// 150
		
//		byte  b = (byte)x;
//		System.out.println(b);// -106
		
//		int x = 150;
//		byte b= (byte)x;
//		System.out.println(b);// -106
		
//		int x = 509;
//		byte b = (byte)x;
//		System.out.println(b);// -3
		
//		int x = 509;
//		short s = (short)x;
//		System.out.println(s);// 509
		
		
		
		
		
//		Float to integral value -- digit after decimal point lost
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		double d = 130.456;
//		int x = (int)d;
//		System.out.println(x);// 130
		
//		double d = 130.456;
//		byte b = (byte)d;
//		System.out.println(b);// -126
		
//		float f = 130.456f;
//		int x = (int)f;
//		System.out.println(x);// 130
		
		
//		Lecture 21: 10.Assignment operators : 
//		Three types
//		1.Simple assingment
//		2.chained 
//		3.compound
		
//		1.Simple:-   int x= 10;
//		int x = 10;
//		literal value 10 assigned to  var x
		
//		2.chained:-  
//		int a,b,c,d;
//		a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
		
		
//		int a,b,c,d;
//		a=b=c=d=10;
//		System.out.println(a+".."+b+".."+c+".."+d);//10..10..10..10

//		We can't performed chain assingment directly at the time of declaration
//		eg:-
//		 int a =b=c=d=20;
//		 System.out.println(a+".."+b+"..."+c+"..."+d);// b cannot be resolved to a variable
//			c cannot be resolved to a variable
//			d cannot be resolved to a variable
//		 at OperatorsAndAssignment.main(OperatorsAndAssignment.java:555)
		
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);// 20..20...20...20
//		int b,c,d;
//		int a=b=c=d=20;
//		System.out.println(a+".."+b+"..."+c+"..."+d);//20..20...20...20
		
//		3.Compound Assignment Operator:-
//		Sometime assignment operator mixed with some other operator then we called that operator is CAO.
		
//		int a= 20;
//		a+=30;// -- a=a+30
//		System.out.println(a);// 50
		
//		int a = 20;
//		a+=30;// -- a=a+30;
//		System.out.println(a);// 50

//		The following are all possible compound assingment operator in java
		
//		+=		&=		>>= right shift operator
//		-=		|=		>>>= unsigned right shift operator
//		*=		^=		<<= left shift operator
//		/=
//		%=   Total === 11
		
//		in case of CAO internal T.C will performed automatically
//		 byte b = 10;
//		 b=b+1;  // max(int,byte,int)
//		 System.out.println(b);// Type mismatch: cannot convert from int to byte
		 
//		byte b =10;
//		b=b+1;// cannot convert from int to byte
//		System.out.println(b);
//		
		
//		byte b = 10;
//		b++;
//		System.out.println(b);// 11

//		 byte b = 10;
//		 b++;
//		 System.out.println(b);// 11
		 
//		 byte b = 10;
//		 b+=1;  // += CAO internal TC is performed.
//		 System.out.println(b);//11
		
//		byte b =10;
//		b+=1; // b=b+1 
//		System.out.println(b);// 11

//		byte b = 127;
//		b+=1;
//		System.out.println(b);//-128
		
//		byte b =127;
//		b+=1;
//		System.out.println(b);// -128
		
//		byte b = 127;
//		b+=127;
//		System.out.println(b);//-2
		
//		byte b =127;
//		b+=129;
//		System.out.println(b);//0
		
//		byte b =127;
//		b+=130;
//		System.out.println(b);//1

//		byte b = 127;
//		b+=3;
//		System.out.println(b);//-126
		
//		int a,c;
//		int b=20; // simple
//		int d; // simple only declared
//		a=c=d=20; //chained 
//		a+= b-= c*= d/= 2; // compound
//		System.out.println(a+"..."+b+"..."+c+"..."+d);// -160...-180...200...10
		
//		int a,c;
//		int b=20;
//		int d;
//		a=c=d=20;//chained
//		a+= 10;
//		b-=5;
//		c*=4;
//		d/=7;
//		System.out.println(a+"..."+b+"..."+c+"..."+d);//30...15...80...2
		
//		int a=10;
//		a+=a+10;
//		System.out.println(a);//30
		
//		int a=10;
//		a+=a+=a+=a-+a-+30;
//		System.out.println(a);
		
//		int a=10;
//		a+=12+12;
//		System.out.println(a);//34

//		int a,b,c,d,e,f,g,h;
//		a=b=c=d=e=f=g=h=10;
//		a+=10;
//		b-=10;
//		c/=10;// return quotient
//		d*=10;
//		e%=10; // return reminder
//		
//		f&=10; // f&10==> 10&10 = Ans 10 - 1010&1010==1010=10
//		g|=10; // 
//		h^=10;// x-OR cap 
//		
//		System.out.println(a); // 20
//		System.out.println(b); // 0
//		System.out.println(c); // 1
//		System.out.println(d); // 100
//		System.out.println(e); /// 0
//		System.out.println(f); // 10
//		System.out.println(g);// 10
//		System.out.println(h); // 0
		
		
//		11.conditional operators: (? :) Ternary operator
//		The only possible ternary operator in java is conditional operator
//		Syntax : 
//		int  x= (10<20)? 30:40;
		
//		is same as in if else condition
//		if(10<20) {
//			System.out.println("30"); // 30
//		}else {
//			System.out.println("40");
//		}
//		System.out.println(x);// 30
//		
//		int x=  (10<20) ? 30 :40;
//		System.out.println(x);//30
		
//		int  x;
//		if(20<30) {
//			x=10;
//		}
//		else {
//			x=20;
//		}
//		System.out.println(x);// 10
		
		
//		neasting of conditional operator is also possible
		
//		 int x = (10>20)?30 :(40>50)?60:70;
//		 System.out.println(x);// 70
//		is same as 
//		if(10>20) {
//			System.out.println("30"); 
//		}else if(40>50) {
//			System.out.println("60");
//		}else {
//			System.out.println("70");// 70
//		}
		
		
//		int x =(10>20)?30 : (40>90)? 40 : 60;
//		System.out.println(x);// 60
		
//		int x= (10>=30)?30:40;
//		System.out.println(x);//40
		
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10==10) ? 50 :60;
//		System.out.println(x);// 50
		
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10==20) ? 50 :60;
//		System.out.println(x);// 60
			
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10!=10) ? 50 :(97.0==97) ?  60  :70;
//		System.out.println(x);// 60
		
//		int x= (10<10) ? 10 : (10>30) ? 20 : (10<=5) ? 30 : (10>=60)? 40 : (10!=10) ? 50 :(97.1==97) ?  60  :70;
//		System.out.println(x);// 70
		
		
		
//		System.out.println(10!=10);//falase
		
		
//		a++, ++a -- unary operator because only one operand is there i.e "a"
//		a+b -- binary operator because two  operand is there i.e "a" and "b"
//		(c)?b:d; ternary operator because three  operand is there i.e "a" , "b" and "c"
		
//		c,b,d are 3 operand
		
//		if(true&&false) {
//			System.out.println("Hii");
//		}
//		else
//		{
//			System.out.println("Hello");
//		}
//		// hello
		
//		if(10>20 && 30<40) {
//			System.out.println("Hii");
//		}else {
//			System.out.println("Hello");
//		}// Hello
		
		
//		if(true && true && true) {
//			System.out.println("Hello");
//		}else
//		{
//			System.out.println("Hello");
//		}// Hello
//		
//		if(true & true & true) {
//			System.out.println("Hello");
//		}else
//		{
//			System.out.println("Hello");
//		}// Hello
		
//		if(10<20 && 30<60 && 40<80 && 50<90 && 60<90) {
//			System.out.println("Hello");
//		}else {
//			System.out.println("Hii");
//		}// Hello
		
//		12.new operators  -- theory only
//		we can use this new operator to create object of class
//		eg:- Test t = new Test();
//		After creating an object constructor will be executed to perform
//		initialization of object not for creation of object
		
//		
//		basically after creation of test class object by using new keyword constructor immideately execute (automatically) and perform initialization of created object
//		so, The  role of constructor is to perform initialization of object not creation of object.
		
		
		
//		13.[] operators -- theory only
		
//		we  can use this operator to declare and create arrays only
//		eg:- 
//		int[] x = new int[10];
//		In general other than arrays we are not going to use this operator anywhere else
		
//		int[] x = new int[10];
		
//		Lecture 22: //		
//		
//		14.operator precedence
		
//		Java operator precedence chart
		
//		1. unary operator
//		[],x++,x--
//		++x,--x,~,|
//		new, <type>
		
//		2.Arithmetic Operator
//		*,/,%
//		+,-
		
//		3.Shift operator
//		>>,>>>,<<
		
//		4.Comparision operator
//		<,<=,>,>=,instanceof
		
//		5.equality operator:
//		==, !=
		
//		6. Bitwise operator
//		&,^,|
		
//		7.Short Circuit operator
//		&&, ||
		
//		8.conditional operator
//		? : 
		
//		9.Assignment operator
//		=, +=, -=, *=     .args.clone(). all  11 CAO
		
//		15.Evaluation order of operands
		
//		If we apply any operator  on operand all operand will evaluated from left to right
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)); // 32
//		 1+2*3/4+5*6
//		 1+6/4+5*6
//		 1+1+30
//		 2+30
//		 32
		
		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6));
		
//		System.out.println(m1(1)+m1(2)*m1(3)/m1(4)+m1(5)*m1(6)*m1(7)/m1(8)+m1(9)-m1(10));// 27
//	    1+2*3/4+5*6*7/8+9-10
//		1+6/4+5*6*7/8+9-10
//		1+1+5*6*7/8+9-10
//		1+1+30*7/8+9-10
//		1+1+210/8+9-10
		1+1
		
//		If multiple operator has same precedence then it execute from left to right
//		and right to left accrdng to associativity.
		
//		For more detail : See Java operator precedence table
		
//		Lecture 23 : 
//		16.new vs newInstance()
//		1.new : - We can use this new operator to create an object , if we know classname at the beggining
//		eg:- 
//		Test t = new Test();
//		Student S = new Student();
//		Customer C = new Customer();
		
//		2. newInstance():- is a method in Class.class we can use newInstance method to create object, 
//		if we don't know class name at begining and it is available dynamically at runtime from
//		CLA,file,database.
//		eg: above
//		17.instanceOf Vs isInstance()
//		18.ClassNotFoundException Vs NoClassDefFoundError
//		both above 17 & 18 point are theory based and interview question only 
		
		
		
		


	}
//	public static int m1(int i) {
//	System.out.println(i);// 1,2,3,4,5,6
//	System.out.println(i);//1,2,3,4,5,6.7,8,9,10
//	return i;
//}
	
	public static int m1(int i) {
		System.out.println(i);
		return i;
	}

}

----------------------------------- SOURCE END -------------------------------------
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 2 2024-01-01 23:28:33.390
!MESSAGE Problems occurred when invoking code from plug-in: "org.eclipse.jdt.core.manipulation".
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)

!ENTRY org.eclipse.jdt.core.manipulation 4 0 2024-01-01 23:28:33.392
!MESSAGE Error in JDT Core during AST creation
!STACK 0
java.lang.IllegalArgumentException
	at org.eclipse.jdt.core.dom.InfixExpression.setOperator(InfixExpression.java:383)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1287)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:2047)
	at org.eclipse.jdt.core.dom.ASTConverter.convertToParenthesizedExpression(ASTConverter.java:3853)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1953)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1204)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1990)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3095)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:751)
	at org.eclipse.jdt.core.dom.ASTConverter.buildBodyDeclarations(ASTConverter.java:208)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:3390)
	at org.eclipse.jdt.core.dom.ASTConverter.convert(ASTConverter.java:1534)
	at org.eclipse.jdt.core.dom.CompilationUnitResolver.convert(CompilationUnitResolver.java:323)
	at org.eclipse.jdt.core.dom.ASTParser.internalCreateAST(ASTParser.java:1271)
	at org.eclipse.jdt.core.dom.ASTParser.createAST(ASTParser.java:868)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider$1.run(CoreASTProvider.java:272)
	at org.eclipse.core.runtime.SafeRunner.run(SafeRunner.java:45)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.createAST(CoreASTProvider.java:264)
	at org.eclipse.jdt.core.manipulation.CoreASTProvider.getAST(CoreASTProvider.java:197)
	at org.eclipse.jdt.core.manipulation.SharedASTProviderCore.getAST(SharedASTProviderCore.java:138)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup.calculateASTandInform(SelectionListenerWithASTManager.java:166)
	at org.eclipse.jdt.internal.ui.viewsupport.SelectionListenerWithASTManager$PartListenerGroup$1.run(SelectionListenerWithASTManager.java:151)
	at org.eclipse.core.internal.jobs.Worker.run(Worker.java:63)
